
#Область Константы

Перем КлючевыеСлова;              // перечисление
Перем Токены;                     // перечисление
Перем Узлы;                       // перечисление
Перем Директивы;                  // перечисление
Перем ИнструкцииПрепроцессора;    // перечисление
Перем СимволыПрепроцессора;       // перечисление
Перем ОсновнойЛитералКромеСтроки; // массив (один из Токены)
Перем ОператорыСравнения;         // массив (один из Токены)
Перем ОператорыСложения;          // массив (один из Токены)
Перем ОператорыУмножения;         // массив (один из Токены)
Перем ТокеныНачалаВыражения;      // массив (один из Токены)
Перем ПустойМассив;               // массив
Перем КартаТокенов;               // соответствие[строка] (строка)
Перем КартаБуквЦифр;              // соответствие[строка] (строка)
Перем Буква, Цифра;               // строка
Перем ПереводСтроки;              // строка

#КонецОбласти // Константы

#Область Настройки

Перем БолтливыйРежим Экспорт;    // булево
Перем Отладка Экспорт;           // булево
Перем ПоложениеУзлаВАСТ Экспорт; // булево

#КонецОбласти // Настройки

#Область СостояниеПарсера

Перем Парсер_Исходник;             // строка
Перем Парсер_Длина;                // число
Перем Парсер_ТекущийНомерСтроки;   // число
Перем Парсер_НомерСтрокиОкончания; // число
Перем Парсер_ТекущаяПозиция;       // число
Перем Парсер_ПозицияНачала;        // число
Перем Парсер_ПозицияОкончания;     // число
Перем Парсер_Символ;               // строка
Перем Парсер_Токен;                // строка (один из Токены)
Перем Парсер_Литерал;              // строка
Перем Парсер_Значение;             // число, строка, дата, булево, неопределено, null
Перем Парсер_Окружение;            // структура (Окружение)
Перем Парсер_Переменные;           // структура как соответствие[строка] (Объект)
Перем Парсер_Методы;               // структура как соответствие[строка] (Объект)
Перем Парсер_Неизвестные;          // структура как соответствие[строка] (Объект)
Перем Парсер_ЭтоФункция;           // булево
Перем Парсер_РазрешеныПерем;       // булево
Перем Парсер_Директива;            // строка (один из Директивы)
Перем Парсер_ПрограммныйИнтерфейс; // массив (Объект)
Перем Парсер_Комментарии;          // соответствие[число] (строка)

#КонецОбласти // СостояниеПарсера

#Область СостояниеПосетителя

Перем Посетитель_Плагины;  // массив (ОбработкаОбъект)
Перем Посетитель_Подписки; // структура как соответствие[строка] (массив)
Перем Посетитель_Стек;     // структура
Перем Посетитель_Счетчики; // структура как соответствие[строка] (число)

#КонецОбласти // СостояниеПосетителя

#Область Инициализировать

Процедура Инициализировать()
	Перем Буквы, Индекс, Символ;

	БолтливыйРежим = Ложь;
	Отладка = Ложь;
	ПоложениеУзлаВАСТ = Истина;

	ИнициализироватьПеречисления();

	ОсновнойЛитералКромеСтроки = Новый Массив;
	ОсновнойЛитералКромеСтроки.Добавить(Токены.Число);
	ОсновнойЛитералКромеСтроки.Добавить(Токены.ДатаВремя);
	ОсновнойЛитералКромеСтроки.Добавить(Токены.Истина);
	ОсновнойЛитералКромеСтроки.Добавить(Токены.Ложь);
	ОсновнойЛитералКромеСтроки.Добавить(Токены.Неопределено);
	ОсновнойЛитералКромеСтроки.Добавить(Токены.Null);

	ОператорыСравнения = Новый Массив;
	ОператорыСравнения.Добавить(Токены.Равенство);
	ОператорыСравнения.Добавить(Токены.НеРавно);
	ОператорыСравнения.Добавить(Токены.Меньше);
	ОператорыСравнения.Добавить(Токены.Больше);
	ОператорыСравнения.Добавить(Токены.МеньшеИлиРавно);
	ОператорыСравнения.Добавить(Токены.БольшеИлиРавно);

	ОператорыСложения = Новый Массив;
	ОператорыСложения.Добавить(Токены.Сложение);
	ОператорыСложения.Добавить(Токены.Вычитание);

	ОператорыУмножения = Новый Массив;
	ОператорыУмножения.Добавить(Токены.Умножение);
	ОператорыУмножения.Добавить(Токены.Деление);
	ОператорыУмножения.Добавить(Токены.Остаток);

	ТокеныНачалаВыражения = Новый Массив;
	ТокеныНачалаВыражения.Добавить(Токены.Сложение);
	ТокеныНачалаВыражения.Добавить(Токены.Вычитание);
	ТокеныНачалаВыражения.Добавить(Токены.Не);
	ТокеныНачалаВыражения.Добавить(Токены.Идентификатор);
	ТокеныНачалаВыражения.Добавить(Токены.ЛеваяКруглаяСкобка);
	ТокеныНачалаВыражения.Добавить(Токены.Число);
	ТокеныНачалаВыражения.Добавить(Токены.Строка);
	ТокеныНачалаВыражения.Добавить(Токены.СтрокаНачало);
	ТокеныНачалаВыражения.Добавить(Токены.ДатаВремя);
	ТокеныНачалаВыражения.Добавить(Токены.ЗнакВопроса);
	ТокеныНачалаВыражения.Добавить(Токены.New);
	ТокеныНачалаВыражения.Добавить(Токены.Истина);
	ТокеныНачалаВыражения.Добавить(Токены.Ложь);
	ТокеныНачалаВыражения.Добавить(Токены.Неопределено);
	ТокеныНачалаВыражения.Добавить(Токены.Null);

	ПустойМассив = Новый Массив;

	ПереводСтроки = Символы.ПС;

	Буква = "Буква";
	Цифра = "Цифра";

	КартаТокенов = Новый Соответствие;
	КартаБуквЦифр = Новый Соответствие;

	Буквы = (
		"abcdefghijklmnopqrstuvwxyz"
		+ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		+ "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"
		+ "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
	);
	Индекс = 1;
	Символ = "_";
	Пока Символ <> "" Цикл
		КартаТокенов[Символ] = Буква;
		КартаБуквЦифр[Символ] = Буква;
		Символ = Сред(Буквы, Индекс, 1);
		Индекс = Индекс + 1;
	КонецЦикла;

	Для Индекс = 0 По 9 Цикл
		КартаТокенов[Строка(Индекс)] = Цифра;
		КартаБуквЦифр[Строка(Индекс)] = Цифра;
	КонецЦикла;

	КартаТокенов[""""] = Токены.Строка;
	КартаТокенов["|"] = Токены.Строка;
	КартаТокенов["'"] = Токены.ДатаВремя;
	КартаТокенов["="] = Токены.Равенство;
	КартаТокенов["+"] = Токены.Сложение;
	КартаТокенов["-"] = Токены.Вычитание;
	КартаТокенов["*"] = Токены.Умножение;
	КартаТокенов["%"] = Токены.Остаток;
	КартаТокенов["("] = Токены.ЛеваяКруглаяСкобка;
	КартаТокенов[")"] = Токены.ПраваяКруглаяСкобка;
	КартаТокенов["["] = Токены.ЛеваяКвадратнаяСкобка;
	КартаТокенов["]"] = Токены.ПраваяКвадратнаяСкобка;
	КартаТокенов["?"] = Токены.ЗнакВопроса;
	КартаТокенов[","] = Токены.Запятая;
	КартаТокенов["."] = Токены.Точка;
	КартаТокенов[":"] = Токены.Двоеточие;
	КартаТокенов[";"] = Токены.ТочкаСЗапятой;
	КартаТокенов[""] = Токены.КонецФайла;

КонецПроцедуры // Инициализировать()

Процедура ИнициализироватьПеречисления()
	КлючевыеСлова = КлючевыеСлова();
	Токены = Токены(КлючевыеСлова);
	Узлы = Узлы();
	Директивы = Директивы();
	ИнструкцииПрепроцессора = ИнструкцииПрепроцессора();
	СимволыПрепроцессора = СимволыПрепроцессора();
КонецПроцедуры // ИнициализироватьПеречисления()

#КонецОбласти // Инициализировать

#Область Enums

Функция КлючевыеСлова() Экспорт
	Возврат Перечисление(Новый Структура,
		"Если.If, Тогда.Then, ИначеЕсли.ElsIf, Иначе.Else, КонецЕсли.EndIf,
		|Для.For, Каждого.Each, Из.In, По.To, Пока.While, Цикл.Do, КонецЦикла.EndDo,
		|Процедура.Procedure, КонецПроцедуры.EndProcedure, Функция.Function, КонецФункции.EndFunction,
		|Перем.Var, Знач.Val, Возврат.Return, Продолжить.Continue, Прервать.Break,
		|И.And, Или.Or, Не.Not,
		|Попытка.Try, Исключение.Except, ВызватьИсключение.Raise, КонецПопытки.EndTry,
		|Новый.New, Выполнить.Execute, Экспорт.Export, Перейти.Goto,
		|Истина.True, Ложь.False, Неопределено.Undefined, Null"
	);
КонецФункции // Keywords()

Функция Токены(КлючевыеСлова = Неопределено) Экспорт
	Перем Токены;

	Если КлючевыеСлова = Неопределено Тогда
		КлючевыеСлова = КлючевыеСлова();
	КонецЕсли;

	Токены = Перечисление(Новый Структура(КлючевыеСлова),

		// Литералы

		"Идентификатор, Число, Строка, ДатаВремя,
		// части строки
		|СтрокаНачало, СтрокаПродолжение, СтрокаОкончание,

		// Операторы

		//       =       <>       <       >              <=              >=         +          -          *        /        %
		|Равенство, НеРавно, Меньше, Больше, МеньшеИлиРавно, БольшеИлиРавно, Сложение, Вычитание, Умножение, Деление, Остаток,
		//                (                    )                      [                       ]
		|ЛеваяКруглаяСкобка, ПраваяКруглаяСкобка, ЛеваяКвадратнаяСкобка, ПраваяКвадратнаяСкобка,
		//         ?        ,      .          :              ;
		|ЗнакВопроса, Запятая, Точка, Двоеточие, ТочкаСЗапятой,

		// Инструкции препроцессора
		|_Если, _ИначеЕсли, _Иначе, _КонецЕсли, _Область, _КонецОбласти, _Использовать,

		// Прочее

		//                    //          &      ~
		|КонецФайла, Комментарий, Директива, Метка"

	);

	Возврат Токены;
КонецФункции // Токены()

Функция Узлы() Экспорт
	Возврат Перечисление(Новый Структура,
		"Модуль, Объект,
		|ОбъявлениеПеременнойУровняМодуля, ОбъявлениеСпискаПеременныхУровняМодуля, ОбъявлениеЛокальнойПеременной,
		|ОбъявлениеАвтоПеременной, ОбъявлениеПараметра, ОбъявлениеМетода, СигнатураПроцедуры, СигнатураФункции,
		|ВыражениеОсновнойЛитерал, ВыражениеПоле, ВыражениеИндекс, ВыражениеИдентификатор, ВыражениеУнарное,
		|ВыражениеБинарное, ВыражениеНовый, ВыражениеТернарное, ВыражениеСкобки, ВыражениеНе, ВыражениеСтрока,
		|ИнструкцияПрисваивания, ИнструкцияВозврат, ИнструкцияПрервать, ИнструкцияПродолжить,
		|ИнструкцияВызватьИсключение, ИнструкцияВыполнить, ИнструкцияПока, ИнструкцияДля, ИнструкцияДляКаждого,
		|ИнструкцияПопытка, ИнструкцияИсключение, ИнструкцияПерейти, ИнструкцияМетка, ИнструкцияВызвать,
		|ИнструкцияЕсли, ИнструкцияИначеЕсли, ИнструкцияИначе, ИнструкцияПрепроцессораЕсли,
		|ИнструкцияПрепроцессораИначеЕсли, ИнструкцияПрепроцессораИначе, ИнструкцияПрепроцессораКонецЕсли,
		|ИнструкцияПрепроцессораОбласть, ИнструкцияПрепроцессораКонецОбласти, ВыражениеПрепроцессораБинарное,
		|ВыражениеПрепроцессораНе, ВыражениеПрепроцессораСимвол, ИнструкцияПрепроцессораИспользовать"
	);
КонецФункции // Узлы()

Функция Директивы() Экспорт
	Возврат Перечисление(Новый Структура,
		"НаКлиенте.AtClient,"
		"НаСервере.AtServer,"
		"НаСервереБезКонтекста.AtServerNoContext,"
		"НаКлиентеНаСервереБезКонтекста.AtClientAtServerNoContext,"
		"НаКлиентеНаСервере.AtClientAtServer"
	);
КонецФункции // Директивы()

Функция ИнструкцииПрепроцессора() Экспорт
	Возврат Перечисление(Новый Структура,
		"Если.If,"
		"ИначеЕсли.ElsIf,"
		"Иначе.Else,"
		"КонецЕсли.EndIf,"
		"Область.Region,"
		"КонецОбласти.EndRegion,"
		"Использовать.Use" // onescript
	);
КонецФункции // ИнструкцииПрепроцессора()

Функция СимволыПрепроцессора() Экспорт
	Возврат Перечисление(Новый Структура,
		"Клиент.Client,"
		"НаКлиенте.AtClient,"
		"НаСервере.AtServer,"
		"МобильноеПриложениеКлиент.MobileAppClient,"
		"МобильноеПриложениеСервер.MobileAppServer,"
		"ТолстыйКлиентОбычноеПриложение.ThickClientИлиdinaryApplication,"
		"ТолстыйКлиентУправляемоеПриложение.ThickClientManagedApplication,"
		"Сервер.Server,"
		"ВнешнееСоединение.ExternalConnection,"
		"ТонкийКлиент.ThinClient,"
		"ВебКлиент.WebClient"
	);
КонецФункции // СимволыПрепроцессора()

Функция Перечисление(Структура, Ключи)
	Перем Элементы, Элемент, СписокЭлементов, Значение;

	Для Каждого Элементы Из СтрРазделить(Ключи, ",", Ложь) Цикл
		СписокЭлементов = СтрРазделить(Элементы, ".", Ложь);
		Значение = СокрЛП(СписокЭлементов[0]);
		Для Каждого Элемент Из СписокЭлементов Цикл
			Структура.Вставить(СокрЛП(Элемент), Значение);
		КонецЦикла;
	КонецЦикла;

	Возврат Новый ФиксированнаяСтруктура(Структура);
КонецФункции // Перечисление()

#КонецОбласти // Enums

#Область АбстрактноеСинтаксическоеДерево

Функция Модуль(Объявления, Авто, Инструкции, Интерфейс, Комментарии)
	// Корень AST. Узел хранит информацию о модуле в целом.
	Возврат Новый Структура( // @Node
		"Тип,"         // строка (один из Узлы)
		"Объявления,"  // массив (один из #Объявления)
		"Авто,"        // массив (Объект)
		"Инструкции,"  // массив (один из #Инструкции)
		"Интерфейс,"   // массив (Объект)
		"Комментарии", // соответствие[число] (строка)
		Узлы.Модуль, Объявления, Авто, Инструкции, Интерфейс, Комментарии);
КонецФункции // Модуль()

#Область Окружение

Функция Окружение(Внешний)
	Возврат Новый Структура(
		"Внешний," // неопределено, структура (Окружение)
		"Объекты," // структура как соответствие[строка] (Объект)
		"Авто",    // массив (Объект)
		Внешний, Новый Структура, Новый Массив);
КонецФункции // Окружение()

Функция Объект(Имя, Объявление = Неопределено)
	// Узел хранит информацию об объекте области видимости.
	// Поле Объявление хранит объявление данного объекта (неопределено = объявление не обнаружено).
	Возврат Новый Структура( // @Node
		"Тип,"        // строка (один из Узлы)
		"Имя,"        // строка
		"Объявление", // неопределено, структура (один из #Объявления)
		Узлы.Объект, Имя, Объявление);
КонецФункции // Объект()

#КонецОбласти // Окружение

#Область Объявления

Функция ОбъявлениеСпискаПеременныхУровняМодуля(Директива, СписокПеременных, Место)
	// Хранит информацию об инструкции объявления переменных уровня модуля.
	// Пример:
	// <pre>
	// &НаКлиенте            // поле "Директива"
	// Перем П1 Экспорт, П2; // поле "Список"
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Директива," // строка (один из Директивы)
		"Список,"    // массив (ОбъявлениеПеременнойУровняМодуля)
		"Место",     // число, структура (Место)
		Узлы.ОбъявлениеСпискаПеременныхУровняМодуля, Директива, СписокПеременных, Место);
КонецФункции // ОбъявлениеСпискаПеременныхУровняМодуля()

Функция ОбъявлениеПеременнойУровняМодуля(Имя, Директива, Экспортировано, Место)
	// Хранит информацию об объявлении переменной уровня модуля.
	// Пример:
	// Объявления переменных заключены в скобки <...>
	// <pre>
	// &НаКлиенте
	// Перем <П1 Экспорт>, <П2>;
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // строка
		"Директива," // строка (один из Директивы)
		"Экспорт,"   // булево
		"Место",     // число, структура (Место)
		Узлы.ОбъявлениеПеременнойУровняМодуля, Имя, Директива, Экспортировано, Место);
КонецФункции // ОбъявлениеПеременнойУровняМодуля()

Функция ОбъявлениеЛокальнойПеременной(Имя, Место)
	// Хранит информацию об объявлении локальной переменной.
	// Пример:
	// Объявления переменных заключены в скобки <...>
	// <pre>
	// Перем <П1>, <П2>;
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Имя,"   // строка
		"Место", // число, структура (Место)
		Узлы.ОбъявлениеЛокальнойПеременной, Имя, Место);
КонецФункции // ОбъявлениеЛокальнойПеременной()

Функция ОбъявлениеАвтоПеременной(Место)
	// Хранит информацию об объявлении авто-переменной.
	// Пример:
	// Объявления переменных заключены в скобки <...>
	// <pre>
	// <Макс> = 0;
	// Для <Индекс> = 0 По Массив.ВГраница() Цикл
	//    <Структура> = Массив[Индекс];
	//     Для Каждого <Элемент> Из Структура Цикл
	//        Если Макс < Элемент.Значение Тогда
	//             Макс = Элемент.Значение;
	//         КонецЕсли;
	//     КонецЦикла;
	// КонецЦикла
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Место", // число, структура (Место)
		Узлы.ОбъявлениеАвтоПеременной, Место);
КонецФункции // ОбъявлениеАвтоПеременной()

Функция ОбъявлениеПараметра(Имя, ПоЗначению, Значение = Неопределено, Место)
	// Хранит информацию об объявлении параметра.
	// Пример:
	// Объявления параметров заключены в скобки <...>
	// <pre>
	// Процедура(<П1>, <Знач П2 = Неопределено>)
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"        // строка (один из Узлы)
		"Имя,"        // строка
		"ПоЗначению," // булево
		"Значение,"   // неопределено, структура (ВыражениеУнарное, ВыражениеОсновнойЛитерал)
		"Место",      // число, структура (Место)
		Узлы.ОбъявлениеПараметра, Имя, ПоЗначению, Значение, Место);
КонецФункции // ОбъявлениеПараметра()

Функция ОбъявлениеМетода(Сигнатура, Объявления, Авто, Инструкции, Место)
	// Хранит информацию об объявлении метода.
	// Сигнатура метода хранится в поле Сигнатура.
	// &НаКлиенте
	// Функция Тест() Экспорт
	//     Перем П1;    // поле "Переменные" хранит объявления переменных.
	//     П1 = 2;      // операторы собираются в поле Инструкции
	//     П2 = П1 + 2; // Авто-переменные (П2) собираются в поле "Авто".
	// КонецФункции
	Возврат Новый Структура( // @Node
		"Тип,"        // строка (один из Узлы)
		"Сигнатура,"  // структура (СигнатураПроцедуры, СигнатураФункции)
		"Переменные," // массив (ОбъявлениеЛокальнойПеременной)
		"Авто,"       // массив (Объект)
		"Инструкции," // массив (один из #Инструкции)
		"Место",      // число, структура (Место)
		Узлы.ОбъявлениеМетода, Сигнатура, Объявления, Авто, Инструкции, Место);
КонецФункции // ОбъявлениеМетода()

Функция СигнатураПроцедуры(Имя, Директива, Параметры, Экспортировано, Место)
	// Хранит информацию о сигнатуре объявления процедуры.
	// Пример:
	// <pre>
	// &НаКлиенте
	// Процедура Тест(П1, П2) Экспорт
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // строка
		"Директива," // строка (один из Директивы)
		"Параметры," // массив (ОбъявлениеПараметра)
		"Экспорт,"   // булево
		"Место",     // число, структура (Место)
		Узлы.СигнатураПроцедуры, Имя, Директива, Параметры, Экспортировано, Место);
КонецФункции // СигнатураПроцедуры()

Функция СигнатураФункции(Имя, Директива, Параметры, Экспортировано, Место)
	// Хранит информацию о сигнатуре объявления функции.
	// Пример:
	// <pre>
	// &НаКлиенте
	// Функция Тест(П1, П2) Экспорт
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // строка
		"Директива," // строка (один из Директивы)
		"Параметры," // массив (ОбъявлениеПараметра)
		"Экспорт,"   // булево
		"Место",     // число, структура (Место)
		Узлы.СигнатураФункции, Имя, Директива, Параметры, Экспортировано, Место);
КонецФункции // СигнатураФункции()

#КонецОбласти // Объявления

#Область Выражения

Функция ВыражениеОсновнойЛитерал(Вид, Значение, Место)
	// Хранит информацию о литерале примитивного типа.
	Возврат Новый Структура( // @Node
		"Тип,"      // строка (один из Узлы)
		"Вид,"      // строка (один из Токены)
		"Значение," // неопределено, строка, число, булево, дата, null
		"Место",    // число, структура (Место)
		Узлы.ВыражениеОсновнойЛитерал, Вид, Значение, Место);
КонецФункции // ВыражениеОсновнойЛитерал()

Функция ВыражениеПоле(Имя, Аргументы, Место)
	// Хранит информацию об обращении к полю объекта через точку.
	// В поле Имя содержится имя поля.
	// В поле Аргументы содержатся аргументы вызова (если это вызов).
	// Пример:
	// <pre>
	// // обращения через точку заключены в скобки <...>
	// Значение = Объект<.Поле>
	// Значение = Объект<.Добавить(П1, П2)>
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // строка
		"Аргументы," // неопределено, массив (неопределено, один из #Выражения)
		"Место",     // число, структура (Место)
		Узлы.ВыражениеПоле, Имя, Аргументы, Место);
КонецФункции // ВыражениеПоле()

Функция ВыражениеИндекс(Выражение, Место)
	// Хранит информацию об обращении к элементу объекта по индексу.
	// Пример:
	// <pre>
	// // обращение по индексу заключено в скобки <...>
	// Значение = Объект<[Ключ]>
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Место",     // число, структура (Место)
		Узлы.ВыражениеИндекс, Выражение, Место);
КонецФункции // ВыражениеИндекс()

Функция ВыражениеИдентификатор(Объект, Хвост, Аргументы, Место)
	// Хранит информацию об обращении к идентификатору.
	// В поле Голова содержится объект области видимости соответствующий идентификатору.
	// В поле Хвост содержится последовательность обращений через точку и по индексу.
	// В поле Аргументы содержатся аргументы вызова (если это вызов).
	// Пример:
	// <pre>
	// // идентификатор заключен в скобки <...>
	// // поле "Голова" будет содержать объект переменной "Запрос";
	// // поле "Хвост" будет содержать три обращения;
	// // поле "Аргументы" будет равно Неопределено, т.к. обращение к "Запрос" не является вызовом.
	// Возврат <Запрос.Выполнить().Выгрузить()[0]>;
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Голова,"    // структура (Объект)
		"Хвост,"     // массив (ВыражениеПоле, ВыражениеИндекс)
		"Аргументы," // неопределено, массив (неопределено, один из #Выражения)
		"Место",     // число, структура (Место)
		Узлы.ВыражениеИдентификатор, Объект, Хвост, Аргументы, Место);
КонецФункции // ВыражениеИдентификатор()

Функция ВыражениеУнарное(Оператор, Операнд, Место)
	// Хранит унарное выражение.
	// Пример:
	// <pre>
	// // унарные выражения заключены в скобки <...>
	// // поле "Оператор" равно либо Токены.Сложение, либо Токены.Вычитание
	// // поле "Операнд" хранит операнд-выражение
	// Значение = <-Сумма> * 2;
	// Значение = <+Сумма>;
	// Значение = <-(Сумма1 + Сумма2)> / 2;
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"      // строка (один из Узлы)
		"Оператор," // строка (один из Токены)
		"Операнд,"  // структура (один из #Выражения)
		"Место",    // число, структура (Место)
		Узлы.ВыражениеУнарное, Оператор, Операнд, Место);
КонецФункции // ВыражениеУнарное()

Функция ВыражениеБинарное(Левый, Оператор, Правый, Место)
	// Хранит бинарное выражение.
	// Пример:
	// <pre>
	// // бинарные выражения заключены в скобки <...>
	// // поле "Оператор" равно одному из допустимых операторов:
	// // - логических (кроме "Не")
	// // - реляционных
	// // - арифметических
	// // поля "Левый" и "Правый" содержат операнды-выражения
	// Если <Не Отмена И Продолжить> Тогда
	//     Значение = <Сумма1 + <Сумма2 * Коэффициент>>;
	// КонецЕсли;
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"      // строка (один из Узлы)
		"Левый,"    // структура (один из #Выражения)
		"Оператор," // строка (один из Токены)
		"Правый,"   // структура (один из #Выражения)
		"Место",    // число, структура (Место)
		Узлы.ВыражениеБинарное, Левый, Оператор, Правый, Место);
КонецФункции // ВыражениеБинарное()

Функция ВыражениеНовый(Имя, Аргументы, Место)
	// Хранит выражение "Новый".
	// Пример:
	// <pre>
	// // выражения "Новый" заключены в скобки <...>
	// // в этом варианте поле "Имя" хранит имя типа "Массив",
	// // а поле "Аргументы" хранит массив из одного выражения
	// Параметры = <Новый Массив(1)>;
	// Параметры[0] = 10;
	// // в этом варианте поле "Имя" равно Неопределено,
	// // а поле "Аргументы" хранит массив из двух выражений
	// Массив = <Новый (Тип("Массив"), Параметры)>;
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // неопределено, строка
		"Аргументы," // массив (один из #Выражения)
		"Место",     // число, структура (Место)
		Узлы.ВыражениеНовый, Имя, Аргументы, Место);
КонецФункции // ВыражениеНовый()

Функция ВыражениеТернарное(Условие, ТогдаЧасть, ИначеЧасть, Хвост, Место)
	// Хранит тернарное выражение "?(,,)".
	// Пример:
	// <pre>
	// Значение = ?(Ложь,   // поле "Условие"
	//     Неопределено,    // поле "Тогда"
	//     Новый Массив     // поле "Иначе"
	// ).Количество();      // поле "Хвост"
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"     // строка (один из Узлы)
		"Условие," // структура (один из #Выражения)
		"Тогда,"   // структура (один из #Выражения)
		"Иначе,"   // структура (один из #Выражения)
		"Хвост,"   // массив (ВыражениеПоле, ВыражениеИндекс)
		"Место",   // число, структура (Место)
		Узлы.ВыражениеТернарное, Условие, ТогдаЧасть, ИначеЧасть, Хвост, Место);
КонецФункции // ВыражениеТернарное()

Функция ВыражениеСкобки(Выражение, Место)
	// Хранит скобочное выражение.
	// Пример:
	// <pre>
	// // скобочное выражение заключено в скобки <...>
	// Сумма = <(Сумма1 + Сумма2)> * Количество;
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Место",     // число, структура (Место)
		Узлы.ВыражениеСкобки, Выражение, Место);
КонецФункции // ВыражениеСкобки()

Функция ВыражениеНе(Выражение, Место)
	// Хранит выражение, к которому применено логическое отрицание "Не".
	// Пример:
	// <pre>
	// // выражение-отрицание заключено в скобки <...>
	// НеРавны = <Не Сумма1 = Сумма2>;
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Место",     // число, структура (Место)
	Узлы.ВыражениеНе, Выражение, Место);
КонецФункции // ВыражениеНе()

Функция ВыражениеСтрока(ВыражениеСписок, Место)
	// Хранит строковое выражение.
	// Поле "Список" хранит упорядоченный список частей строки.
	// Пример:
	// <pre>
	// Строка1 = "Часть1" "Часть2"; // эта строка состоит из двух частей типа Узлы.Строка
	// Строка2 =                    // эта строка состоит из пяти частей типа:
	// "Начало строки               // Узлы.СтрокаНачало
	// | продолжение строки         // Узлы.СтрокаПродолжение
	// | еще продолжение строки     // Узлы.СтрокаПродолжение
	// | окончание строки"          // Узлы.СтрокаОкончание
	// "еще часть";                 // Узлы.Строка
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"    // строка (один из Узлы)
		"Список," // массив (ВыражениеОсновнойЛитерал)
		"Место",  // число, структура (Место)
		Узлы.ВыражениеСтрока, ВыражениеСписок, Место);
КонецФункции // ВыражениеСтрока()

#КонецОбласти // Выражения

#Область Инструкции

Функция ИнструкцияПрисваивания(Левый, Правый, Место)
	// Хранит оператор присваивания.
	Возврат Новый Структура( // @Node
		"Тип,"    // строка (один из Узлы)
		"Левый,"  // структура (ВыражениеИдентификатор)
		"Правый," // структура (один из #Выражения)
		"Место",  // число, структура (Место)
		Узлы.ИнструкцияПрисваивания, Левый, Правый, Место);
КонецФункции // ИнструкцияПрисваивания()

Функция ИнструкцияВозврат(Выражение = Неопределено, Место)
	// Хранит оператор "Возврат".
	// Поле "Выражение" равно Неопределено если это возврат из процедуры.
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Выражение," // неопределено, структура (один из #Выражения)
		"Место",     // число, структура (Место)
		Узлы.ИнструкцияВозврат, Выражение, Место);
КонецФункции // ИнструкцияВозврат()

Функция ИнструкцияПрервать(Место)
	// Хранит оператор "Прервать".
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Место", // число, структура (Место)
		Узлы.ИнструкцияПрервать, Место);
КонецФункции // ИнструкцияПрервать()

Функция ИнструкцияПродолжить(Место)
	// Хранит оператор "Продолжить".
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Место", // число, структура (Место)
		Узлы.ИнструкцияПродолжить, Место);
КонецФункции // ИнструкцияПродолжить()

Функция ИнструкцияВызватьИсключение(Выражение = Неопределено, Место)
	// Хранит оператор "ВызватьИсключение".
	// Поле "Выражение" равно Неопределено если это вариант оператора без выражения.
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Выражение," // неопределено, структура (один из #Выражения)
		"Место",     // число, структура (Место)
		Узлы.ИнструкцияВызватьИсключение, Выражение, Место);
КонецФункции // ИнструкцияВызватьИсключение()

Функция ИнструкцияВыполнить(Выражение, Место)
	// Хранит оператор "Выполнить".
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Место",     // число, структура (Место)
		Узлы.ИнструкцияВыполнить, Выражение, Место);
КонецФункции // ИнструкцияВыполнить()

Функция ИнструкцияВызвать(ВыражениеИдентификатор, Место)
	// Хранит вызов процедуры или функции как процедуры.
	Возврат Новый Структура( // @Node
		"Тип,"           // строка (один из Узлы)
		"Идентификатор," // структура (ВыражениеИдентификатор)
		"Место",         // число, структура (Место)
		Узлы.ИнструкцияВызвать, ВыражениеИдентификатор, Место);
КонецФункции // ИнструкцияВызвать()

Функция ИнструкцияЕсли(Условие, ТогдаЧасть, ИначеЕслиЧасть = Неопределено, ИначеЧасть = Неопределено, Место)
	// Хранит оператор "Если".
	// Пример:
	// <pre>
	// Если Сумма > 0 Тогда // поле "Условие" хранит условие (выражение)
	//     // поле "Тогда" хранит операторы в этом блоке
	// ИначеЕсли Сумма = 0 Тогда
	//     // поле-массив "ИначеЕсли" хранит последовательность блоков ИначеЕсли
	// Иначе
	//     // поле "Иначе" хранит операторы в этом блоке
	// КонецЕсли
	// </pre>
	// Поля "ИначеЕсли" и "Иначе" равны Неопределено если
	// соответствующие блоки отсутствуют в исходном коде.
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Условие,"   // структура (один из #Выражения)
		"Тогда,"     // массив (один из #Инструкции)
		"ИначеЕсли," // неопределено, массив (ИнструкцияИначеЕсли)
		"Иначе,"     // неопределено, структура (ИнструкцияИначе)
		"Место",     // число, структура (Место)
		Узлы.ИнструкцияЕсли, Условие, ТогдаЧасть, ИначеЕслиЧасть, ИначеЧасть, Место);
КонецФункции // ИнструкцияЕсли()

Функция ИнструкцияИначе(Инструкции, Место)
	// Хранит блок "Иначе"
	Возврат Новый Структура( // @Node
		"Тип,"        // строка (один из Узлы)
		"Инструкции," // массив (один из #Инструкции)
		"Место",      // число, структура (Место)
		Узлы.ИнструкцияИначе, Инструкции, Место);
КонецФункции // ИнструкцияИначе()

Функция ИнструкцияИначеЕсли(Условие, ТогдаЧасть, Место)
	// Хранит блок "ИначеЕсли" оператора "Если".
	// Пример:
	// <pre>
	// ...
	// ИначеЕсли Сумма < 0 Тогда // поле "Условие" хранит условие (выражение)
	//     // поле "Тогда" хранит операторы в этом блоке
	// ...
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"     // строка (один из Узлы)
		"Условие," // структура (один из #Выражения)
		"Тогда,"   // массив (один из #Инструкции)
		"Место",   // число, структура (Место)
		Узлы.ИнструкцияИначеЕсли, Условие, ТогдаЧасть, Место);
КонецФункции // ИнструкцияИначеЕсли()

Функция ИнструкцияПока(Условие, Инструкции, Место)
	// Хранит оператор цикла "Пока".
	// Пример:
	// <pre>
	// Пока Индекс > 0 Цикл // поле "Условие" хранит условие (выражение)
	//     // поле "Инструкции" хранит операторы в этом блоке
	// КонецЦикла
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"        // строка (один из Узлы)
		"Условие,"    // структура (один из #Выражения)
		"Инструкции," // массив (один из #Инструкции)
		"Место",      // число, структура (Место)
		Узлы.ИнструкцияПока, Условие, Инструкции, Место);
КонецФункции // ИнструкцияПока()

Функция ИнструкцияДля(ВыражениеИдентификатор, НачинаяС, До, Инструкции, Место)
	// Хранит оператор цикла "Для".
	// Пример:
	// <pre>
	// Для Индекс = 0      // поля "Идентификатор" и "НачинаяС" хранят переменную и выражение инициализации.
	//   По Длина - 1 Цикл // поле "По" хранит выражение границы
	//     // поле "Инструкции" хранит операторы в этом блоке
	// КонецЦикла
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"           // строка (один из Узлы)
		"Идентификатор," // структура (ВыражениеИдентификатор)
		"НачинаяС,"      // структура (один из #Выражения)
		"По,"            // структура (один из #Выражения)
		"Инструкции,"    // массив (один из #Инструкции)
		"Место",         // число, структура (Место)
		Узлы.ИнструкцияДля, ВыражениеИдентификатор, НачинаяС, До, Инструкции, Место);
КонецФункции // ИнструкцияДля()

Функция ИнструкцияДляКаждого(ВыражениеИдентификатор, Коллекция, Инструкции, Место)
	// Хранит оператор цикла "Для Каждого".
	// Пример:
	// <pre>
	// Для Каждого Элемент // поле "Идентификатор" хранит переменную.
	//   Из Список Цикл    // поле "Из" хранит выражение коллекции.
	//     // поле "Инструкции" хранит операторы в этом блоке
	// КонецЦикла
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"           // строка (один из Узлы)
		"Идентификатор," // структура (ВыражениеИдентификатор)
		"Из,"            // структура (один из #Выражения)
		"Инструкции,"    // массив (один из #Инструкции)
		"Место",         // число, структура (Место)
		Узлы.ИнструкцияДляКаждого, ВыражениеИдентификатор, Коллекция, Инструкции, Место);
КонецФункции // ИнструкцияДляКаждого()

Функция ИнструкцияПопытка(ПопыткаЧасть, ИсключениеЧасть, Место)
	// Хранит оператор "Попытка"
	// Пример:
	// <pre>
	// Попытка
	//     // поле "Попытка" хранит операторы в этом блоке.
	// Исключение
	//     // поле "Исключение" хранит операторы в этом блоке
	// КонецПопытки
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"        // строка (один из Узлы)
		"Попытка,"    // массив (один из #Инструкции)
		"Исключение," // структура (ИнструкцияИсключение)
		"Место",      // число, структура (Место)
		Узлы.ИнструкцияПопытка, ПопыткаЧасть, ИсключениеЧасть, Место);
КонецФункции // ИнструкцияПопытка()

Функция ИнструкцияИсключение(Инструкции, Место)
	// Хранит блок "Исключение"
	Возврат Новый Структура( // @Node
		"Тип,"        // строка (один из Узлы)
		"Инструкции," // массив (один из #Инструкции)
		"Место",      // число, структура (Место)
		Узлы.ИнструкцияИсключение, Инструкции, Место);
КонецФункции // ИнструкцияИсключение()

Функция ИнструкцияПерейти(Метка, Место)
	// Хранит оператор "Перейти"
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Метка," // строка
		"Место", // число, структура (Место)
		Узлы.ИнструкцияПерейти, Метка, Место);
КонецФункции // ИнструкцияПерейти()

Функция ИнструкцияМетка(Метка, Место)
	// Хранит оператор метки.
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Метка," // строка
		"Место", // число, структура (Место)
		Узлы.ИнструкцияМетка, Метка, Место);
КонецФункции // ИнструкцияМетка()

#КонецОбласти // Инструкции

#Область ИнструкцияПрепроцессора

Функция ИнструкцияПрепроцессораЕсли(Условие, Место)
	// Хранит информацию об инструкции препроцессора #Если,
	// Пример:
	// <pre>
	// ...
	// #Если Сервер Тогда // поле "Условие" хранит условие (выражение)
	// ...
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"     // строка (один из Узлы)
		"Условие," // структура (один из #ВыражениеПрепроцессора)
		"Место",   // число, структура (Место)
		Узлы.ИнструкцияПрепроцессораЕсли, Условие, Место);
КонецФункции // ИнструкцияПрепроцессораЕсли()

Функция ИнструкцияПрепроцессораИначеЕсли(Условие, Место)
	// Хранит информацию об инструкции препроцессора #ИначеЕсли
	// Пример:
	// <pre>
	// ...
	// #ИначеЕсли Клиент Тогда // поле "Условие" хранит условие (выражение)
	// ...
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"     // строка (один из Узлы)
		"Условие," // структура (один из #ВыражениеПрепроцессора)
		"Место",   // число, структура (Место)
		Узлы.ИнструкцияПрепроцессораИначеЕсли, Условие, Место);
КонецФункции // ИнструкцияПрепроцессораИначеЕсли()

Функция ИнструкцияПрепроцессораИначе(Место)
	// Хранит информацию об инструкции препроцессора #Иначе
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Место", // число, структура (Место)
		Узлы.ИнструкцияПрепроцессораИначе, Место);
КонецФункции // ИнструкцияПрепроцессораИначе()

Функция ИнструкцияПрепроцессораКонецЕсли(Место)
	// Хранит информацию об инструкции препроцессора #КонецЕсли
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Место", // число, структура (Место)
		Узлы.ИнструкцияПрепроцессораКонецЕсли, Место);
КонецФункции // ИнструкцияПрепроцессораКонецЕсли()

Функция ИнструкцияПрепроцессораОбласть(Имя, Место)
	// Хранит информацию об инструкции препроцессора #Обрасть,
	// Пример:
	// <pre>
	// ...
	// #Область Интерфейс   // поле "Имя" хранит имя области
	// ...
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Имя,"   // строка
		"Место", // число, структура (Место)
		Узлы.ИнструкцияПрепроцессораОбласть, Имя, Место);
КонецФункции // ИнструкцияПрепроцессораОбласть()

Функция ИнструкцияПрепроцессораКонецОбласти(Место)
	// Хранит информацию об инструкции препроцессора #КонецОбласти,
	// Пример:
	// <pre>
	// ...
	// #КонецОбласти
	// ...
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"   // строка (один из Узлы)
		"Место", // число, структура (Место)
		Узлы.ИнструкцияПрепроцессораКонецОбласти, Место);
КонецФункции // ИнструкцияПрепроцессораКонецОбласти()

Функция ИнструкцияПрепроцессораИспользовать(Путь, Место)
	// Хранит информацию об инструкции препроцессора #Использовать,
	// Это нестандартная инструкция из OneScript
	// Пример:
	// <pre>
	// #Использовать 1commands // поле "Путь" хранит имя библиотеки или путь в кавычках
	// </pre>
	Возврат Новый Структура( // @Node @OneScript
		"Тип,"   // строка (один из Узлы)
		"Путь,"  // строка
		"Место", // число, структура (Место)
		Узлы.ИнструкцияПрепроцессораИспользовать, Путь, Место);
КонецФункции // ИнструкцияПрепроцессораИспользовать()

#КонецОбласти // ИнструкцияПрепроцессора

#Область ВыражениеПрепроцессора

Функция ВыражениеПрепроцессораБинарное(Левый, Оператор, Правый, Место)
	// Хранит бинарное выражение препроцессора.
	// Пример:
	// <pre>
	// // бинарные выражения заключены в скобки <...>
	// // поле "Оператор" равно либо Токены.Или либо Токены.И:
	// // поля "Левый" и "Правый" содержат операнды-выражения препроцессора
	// #Если <Сервер Или ВнешнееСоединение> Тогда
	// ...
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"      // строка (один из Узлы)
		"Левый,"    // структура (один из #ВыражениеПрепроцессора)
		"Оператор," // строка (один из Токены)
		"Правый,"   // структура (один из #ВыражениеПрепроцессора)
		"Место",    // число, структура (Место)
		Узлы.ВыражениеПрепроцессораБинарное, Левый, Оператор, Правый, Место);
КонецФункции // ВыражениеПрепроцессораБинарное()

Функция ВыражениеПрепроцессораНе(Выражение, Место)
	// Хранит выражение препроцессора, к которому применено логическое отрицание "Не".
	// Пример:
	// <pre>
	// // выражение-отрицание заключено в скобки <...>
	// #Если <Не ВебКлиент> Тогда
	// ...
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #ВыражениеПрепроцессора)
		"Место",     // число, структура (Место)
		Узлы.ВыражениеПрепроцессораНе, Выражение, Место);
КонецФункции // ВыражениеПрепроцессораНе()

Функция ВыражениеПрепроцессораСимвол(Символ, Существует, Место)
	// Узел хранит информацию о символе препроцессора.
	// Поле Существует = Истина если такой символ существует.
	// Пример:
	// <pre>
	// // символ заключен в скобки <...>
	// #Если <Сервер> Тогда
	// </pre>
	Возврат Новый Структура( // @Node
		"Тип,"        // строка (один из Узлы)
		"Символ,"     // строка (один из PrepСимволы)
		"Существует," // булево
		"Место",      // число, структура (Место)
		Узлы.ВыражениеПрепроцессораСимвол, Символ, Существует, Место);
КонецФункции // ВыражениеПрепроцессораСимвол()

#КонецОбласти // ВыражениеПрепроцессора

#КонецОбласти // АбстрактноеСинтаксическоеДерево

#Область Парсер

Функция СледующийТокен()
	Перем ПозицияНачала, ПредыдущийСимвол, Комментарий;

	Парсер_ПозицияОкончания = Парсер_ТекущаяПозиция;
	Парсер_НомерСтрокиОкончания = Парсер_ТекущийНомерСтроки;

	Если Прав(Парсер_Литерал, 1) = ПереводСтроки Тогда
		Парсер_ТекущийНомерСтроки = Парсер_ТекущийНомерСтроки + 1;
	КонецЕсли;

	Пока Истина Цикл

		Комментарий = Ложь;

		// пропуск невидимых символов
		Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
			Если Парсер_Символ = ПереводСтроки Тогда
				Парсер_ТекущийНомерСтроки = Парсер_ТекущийНомерСтроки + 1;
			КонецЕсли;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
		КонецЦикла;

		Парсер_ПозицияНачала = Парсер_ТекущаяПозиция;

		Парсер_Токен = КартаТокенов[Парсер_Символ];
		Если Парсер_Токен = Буква Тогда

			// анализ идентификатора
			ПозицияНачала = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			КонецЦикла;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			Парсер_Литерал = Сред(Парсер_Исходник, ПозицияНачала, Парсер_ТекущаяПозиция - ПозицияНачала);

			// сопоставление токена
			Если Не КлючевыеСлова.Свойство(Парсер_Литерал, Парсер_Токен) Тогда
				Парсер_Токен = Токены.Идентификатор;
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Токены.Строка Тогда

			ПозицияНачала = Парсер_ТекущаяПозиция;
			Парсер_Символ = """"; // лазейка
			Пока Парсер_Символ = """" Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Пока Парсер_Символ <> """" И Парсер_Символ <> ПереводСтроки И Парсер_Символ <> "" Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;
				Если Парсер_Символ <> "" Тогда
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЕсли;
			КонецЦикла;
			Парсер_Литерал = Сред(Парсер_Исходник, ПозицияНачала, Парсер_ТекущаяПозиция - ПозицияНачала);

			Парсер_Токен = ТокенСтроки(Парсер_Литерал);

		ИначеЕсли Парсер_Токен = Цифра Тогда

			ПозицияНачала = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Цифра Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			КонецЦикла;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			Если Парсер_Символ = "." Тогда
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Цифра Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			КонецЕсли;
			Парсер_Литерал = Сред(Парсер_Исходник, ПозицияНачала, Парсер_ТекущаяПозиция - ПозицияНачала);

			Парсер_Токен = Токены.Число;

		ИначеЕсли Парсер_Токен = Токены.ДатаВремя Тогда

			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			ПозицияНачала = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = СтрНайти(Парсер_Исходник, "'", , Парсер_ТекущаяПозиция);
			Если Парсер_ТекущаяПозиция = 0 Тогда
				Парсер_Символ = "";
			Иначе
				Парсер_Литерал = Сред(Парсер_Исходник, ПозицияНачала, Парсер_ТекущаяПозиция - ПозицияНачала);
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Неопределено Тогда

			ПредыдущийСимвол = Парсер_Символ;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);

			Если ПредыдущийСимвол = "/" Тогда

				Если Парсер_Символ = "/" Тогда
					// анализ комментария
					ПозицияНачала = Парсер_ТекущаяПозиция + 1;
					Парсер_ТекущаяПозиция = СтрНайти(Парсер_Исходник, ПереводСтроки, , ПозицияНачала);
					Парсер_Комментарии[Парсер_ТекущийНомерСтроки] = Сред(Парсер_Исходник, ПозицияНачала, Парсер_ТекущаяПозиция - ПозицияНачала);
					Если Парсер_ТекущаяПозиция = 0 Тогда
						Парсер_Символ = "";
					Иначе
						Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
					КонецЕсли;
					Комментарий = Истина;
				Иначе
					Парсер_Токен = Токены.Деление;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "<" Тогда

				Если Парсер_Символ = ">" Тогда
					Парсер_Токен = Токены.НеРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				ИначеЕсли Парсер_Символ = "=" Тогда
					Парсер_Токен = Токены.МеньшеИлиРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Иначе
					Парсер_Токен = Токены.Меньше;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = ">" Тогда

				Если Парсер_Символ = "=" Тогда
					Парсер_Токен = Токены.БольшеИлиРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Иначе
					Парсер_Токен = Токены.Больше;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "&" Тогда

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Буква Тогда
					Ошибка("Ожидается директива", Парсер_ТекущаяПозиция, Истина);
				КонецЕсли;

				// анализ идентификатора
				ПозицияНачала = Парсер_ТекущаяПозиция;
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Парсер_Литерал = Сред(Парсер_Исходник, ПозицияНачала, Парсер_ТекущаяПозиция - ПозицияНачала);

				// Если Не Директивы.Свойство(Парсер_Литерал) Тогда
				// 	Ошибка(СтрШаблон("Неизвестная директива: '%1'", Парсер_Литерал));
				// КонецЕсли;

				Парсер_Токен = Токены.Директива;
				Пока Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1) <> ПереводСтроки Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				// Сообщить(Сред(Парсер_Исходник, Парсер_ТекущаяПозиция-1, 1));
			ИначеЕсли ПредыдущийСимвол = "#" Тогда

				// пропуск невидимых символов
				Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
					Если Парсер_Символ = ПереводСтроки Тогда
						Парсер_ТекущийНомерСтроки = Парсер_ТекущийНомерСтроки + 1;
					КонецЕсли;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Буква Тогда
					Ошибка("Ожидается инструкция препроцессора", Парсер_ТекущаяПозиция, Истина);
				КонецЕсли;

				// анализ идентификатора
				ПозицияНачала = Парсер_ТекущаяПозиция;
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Парсер_Литерал = Сред(Парсер_Исходник, ПозицияНачала, Парсер_ТекущаяПозиция - ПозицияНачала);

				// сопоставление токена
				Если ИнструкцииПрепроцессора.Свойство(Парсер_Литерал, Парсер_Токен) Тогда
					Парсер_Токен = "_" + Парсер_Токен;
				Иначе
					Ошибка(СтрШаблон("Неизвестная инструкция препроцессора: '%1'", Парсер_Литерал));
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "~" Тогда

				// пропуск невидимых символов
				Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
					Если Парсер_Символ = ПереводСтроки Тогда
						Парсер_ТекущийНомерСтроки = Парсер_ТекущийНомерСтроки + 1;
					КонецЕсли;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Неопределено Тогда
					Парсер_Литерал = "";
				Иначе
					// анализ идентификатора
					ПозицияНачала = Парсер_ТекущаяПозиция;Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
						Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					КонецЦикла;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
					Парсер_Литерал = Сред(Парсер_Исходник, ПозицияНачала, Парсер_ТекущаяПозиция - ПозицияНачала);
				КонецЕсли;

				Парсер_Токен = Токены.Метка;

			Иначе

				ВызватьИсключение "Неизвестный символ!";

			КонецЕсли;

		Иначе

			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);

		КонецЕсли;

		Если Не Комментарий Тогда
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Если Парсер_Токен = Токены.Число Тогда
		Парсер_Значение = Число(Парсер_Литерал);
	ИначеЕсли Парсер_Токен = Токены.Истина Тогда
		Парсер_Значение = Истина;
	ИначеЕсли Парсер_Токен = Токены.Ложь Тогда
		Парсер_Значение = Ложь;
	ИначеЕсли Парсер_Токен = Токены.ДатаВремя Тогда
		Парсер_Значение = КакДата(Парсер_Литерал);
	ИначеЕсли Лев(Парсер_Токен, 6) = Токены.Строка Тогда
		Парсер_Значение = Сред(Парсер_Литерал, 2, СтрДлина(Парсер_Литерал) - 2);
	ИначеЕсли Парсер_Токен = Токены.Null Тогда
		Парсер_Значение = Null;
	Иначе
		Парсер_Значение = Неопределено;
	КонецЕсли;

	Возврат Парсер_Токен;

КонецФункции // СледующийТокен()

Функция НайтиОбъект(Имя)
	Перем Окружение, Объект;
	Окружение = Парсер_Окружение;
	Окружение.Объекты.Свойство(Имя, Объект);
	Пока Объект = Неопределено И Окружение.Внешний <> Неопределено Цикл
		Окружение = Окружение.Внешний;
		Окружение.Объекты.Свойство(Имя, Объект);
	КонецЦикла;
	Возврат Объект;
КонецФункции // НайтиОбъект()

Функция ОткрытьОкружение()
	Перем Окружение;
	Окружение = Окружение(Парсер_Окружение);
	Парсер_Окружение = Окружение;
	Парсер_Переменные = Окружение.Объекты;
	Возврат Окружение;
КонецФункции // ОткрытьОкружение()

Функция ЗакрытьОкружение()
	Перем Окружение;
	Окружение = Парсер_Окружение.Внешний;
	Парсер_Окружение = Окружение;
	Парсер_Переменные = Окружение.Объекты;
	Возврат Окружение;
КонецФункции // ЗакрытьОкружение()

Функция РазобратьМодуль(Исходник) Экспорт
	Перем Объявления, Авто, ОбъектПеременной, Элемент, Инструкции, Модуль;
	Парсер_Исходник = Исходник;
	Парсер_ТекущаяПозиция = 0;
	Парсер_ТекущийНомерСтроки = 1;
	Парсер_НомерСтрокиОкончания = 1;
	Парсер_ПозицияНачала = 0;
	Парсер_ПозицияОкончания = 0;
	Парсер_Методы = Новый Структура;
	Парсер_Неизвестные = Новый Структура;
	Парсер_ЭтоФункция = Ложь;
	Парсер_РазрешеныПерем = Истина;
	Парсер_ПрограммныйИнтерфейс = Новый Массив;
	Парсер_Комментарии = Новый Соответствие;
	Парсер_Длина = СтрДлина(Исходник);
	Парсер_Литерал = "";
	Парсер_Символ = Неопределено;
	ОткрытьОкружение();
	СледующийТокен();
	Объявления = РазобратьОбъявленияМодуля();
	Инструкции = РазобратьИнструкции();
	Авто = Новый Массив;
	Для Каждого ОбъектПеременной Из Парсер_Окружение.Авто Цикл
		Авто.Добавить(ОбъектПеременной);
	КонецЦикла;
	Модуль = Модуль(Объявления, Авто, Инструкции, Парсер_ПрограммныйИнтерфейс, Парсер_Комментарии);
	Если БолтливыйРежим Тогда
		Для Каждого Элемент Из Парсер_Неизвестные Цикл
			Сообщить(СтрШаблон("Необъявленный метод `%1`", Элемент.Key));
		КонецЦикла;
	КонецЕсли;
	Ожидается(Токены.КонецФайла);
	Парсер_Неизвестные = Неопределено;
	Парсер_Методы = Неопределено;
	Парсер_Директива = Неопределено;
	Парсер_ПрограммныйИнтерфейс = Неопределено;
	Парсер_Комментарии = Неопределено;
	Парсер_Окружение = Неопределено;
	Парсер_Переменные = Неопределено;
	Парсер_Исходник = Неопределено;
	Возврат Модуль;
КонецФункции // РазобратьМодуль()

#Область РазборВыражений

Функция РазобратьВыражение()
	Перем Выражение, Оператор, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Выражение = РазобратьВыражениеИ();
	Пока Парсер_Токен = Токены.Или Цикл
		Оператор = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(Выражение, Оператор, РазобратьВыражениеИ(), Место(Позиция, НомерСтроки));
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражение()

Функция РазобратьВыражениеИ()
	Перем Выражение, Оператор, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Выражение = РазобратьВыражениеНе();
	Пока Парсер_Токен = Токены.И Цикл
		Оператор = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(Выражение, Оператор, РазобратьВыражениеНе(), Место(Позиция, НомерСтроки));
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеИ()

Функция РазобратьВыражениеНе()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Если Парсер_Токен = Токены.Не Тогда
		СледующийТокен();
		Выражение = ВыражениеНе(РазобратьВыражениеСравнения(), Место(Позиция, НомерСтроки));
	Иначе
		Выражение = РазобратьВыражениеСравнения();
	КонецЕсли;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеНе()

Функция РазобратьВыражениеСравнения()
	Перем Выражение, Оператор, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Выражение = РазобратьВыражениеСложения();
	Пока ОператорыСравнения.Найти(Парсер_Токен) <> Неопределено Цикл
		Оператор = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(Выражение, Оператор, РазобратьВыражениеСложения(), Место(Позиция, НомерСтроки));
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеСравнения()

Функция РазобратьВыражениеСложения()
	Перем Выражение, Оператор, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Выражение = РазобратьВыражениеУмножения();
	Пока ОператорыСложения.Найти(Парсер_Токен) <> Неопределено Цикл
		Оператор = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(Выражение, Оператор, РазобратьВыражениеУмножения(), Место(Позиция, НомерСтроки));
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеСложения()

Функция РазобратьВыражениеУмножения()
	Перем Выражение, Оператор, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Выражение = РазобратьВыражениеУнарное();
	Пока ОператорыУмножения.Найти(Парсер_Токен) <> Неопределено Цикл
		Оператор = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(Выражение, Оператор, РазобратьВыражениеУнарное(), Место(Позиция, НомерСтроки));
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеУмножения()

Функция РазобратьВыражениеУнарное()
	Перем Оператор, Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Оператор = Парсер_Токен;
	Если ОператорыСложения.Найти(Парсер_Токен) <> Неопределено Тогда
		СледующийТокен();
		Выражение = ВыражениеУнарное(Оператор, РазобратьОперанд(), Место(Позиция, НомерСтроки));
	ИначеЕсли Парсер_Токен = Токены.КонецФайла Тогда
		Выражение = Неопределено;
	Иначе
		Выражение = РазобратьОперанд();
	КонецЕсли;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеУнарное()

Функция РазобратьОперанд()
	Перем Токен, Операнд;
	Токен = Парсер_Токен;
	Если Токен = Токены.Строка Или Токен = Токены.СтрокаНачало Тогда
		Операнд = РазобратьВыражениеСтрока();
	ИначеЕсли ОсновнойЛитералКромеСтроки.Найти(Токен) <> Неопределено Тогда
		Операнд = ВыражениеОсновнойЛитерал(Токен, Парсер_Значение, Место());
		СледующийТокен();
	ИначеЕсли Токен = Токены.Идентификатор Тогда
		Операнд = РазобратьВыражениеИдентификатор();
	ИначеЕсли Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Операнд = РазобратьВыражениеСкобки();
	ИначеЕсли Токен = Токены.New Тогда
		Операнд = РазобратьВыражениеНовый();
	ИначеЕсли Токен = Токены.ЗнакВопроса Тогда
		Операнд = РазобратьВыражениеТернарное();
	Иначе
		Ошибка("Ожидается операнд", , Истина);
	КонецЕсли;
	Возврат Операнд;
КонецФункции // РазобратьОперанд()

Функция РазобратьВыражениеСтрока()
	Перем Токен, ВыражениеСписок, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Токен = Парсер_Токен;
	ВыражениеСписок = Новый Массив;
	Пока Истина Цикл
		Если Токен = Токены.Строка Тогда
			ВыражениеСписок.Добавить(ВыражениеОсновнойЛитерал(Токен, Парсер_Значение, Место()));
			Токен = СледующийТокен();
			Пока Токен = Токены.Строка Цикл
				ВыражениеСписок.Добавить(ВыражениеОсновнойЛитерал(Токен, Парсер_Значение, Место()));
				Токен = СледующийТокен();
			КонецЦикла;
		ИначеЕсли Токен = Токены.СтрокаНачало Тогда
			ВыражениеСписок.Добавить(ВыражениеОсновнойЛитерал(Токен, Парсер_Значение, Место()));
			Токен = СледующийТокен();
			Пока Токен = Токены.СтрокаПродолжение Цикл
				ВыражениеСписок.Добавить(ВыражениеОсновнойЛитерал(Токен, Парсер_Значение, Место()));
				Токен = СледующийТокен();
			КонецЦикла;
			Если Токен <> Токены.СтрокаОкончание Тогда
				Ошибка("Ожидается """, , Истина);
			КонецЕсли;
			ВыражениеСписок.Добавить(ВыражениеОсновнойЛитерал(Токен, Парсер_Значение, Место()));
			Токен = СледующийТокен();
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат ВыражениеСтрока(ВыражениеСписок, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьВыражениеСтрока()

Функция РазобратьВыражениеНовый()
	Перем Токен, Имя, Аргументы, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Токен = СледующийТокен();
	Если Токен = Токены.Идентификатор Тогда
		Имя = Парсер_Литерал;
		Аргументы = ПустойМассив;
		Токен = СледующийТокен();
	КонецЕсли;
	Если Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Токен = СледующийТокен();
		Если Токен <> Токены.ПраваяКруглаяСкобка Тогда
			Аргументы = РазобратьАргументы();
			Ожидается(Токены.ПраваяКруглаяСкобка);
		КонецЕсли;
		СледующийТокен();
	КонецЕсли;
	Если Имя = Неопределено И Аргументы = Неопределено Тогда
		Ошибка("Ожидается конструктор", Парсер_ПозицияОкончания, Истина);
	КонецЕсли;
	Возврат ВыражениеНовый(Имя, Аргументы, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьВыражениеНовый()

Функция РазобратьВыражениеИдентификатор(Знач РазрешитьНовуюПеременную = Ложь, НоваяПеременная = Неопределено, Вызов = Неопределено)
	Перем Имя, Объект, Хвост, Аргументы, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Имя = Парсер_Литерал;
	АвтоМесто = Место();
	СледующийТокен();
	Если Парсер_Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Если СледующийТокен() = Токены.ПраваяКруглаяСкобка Тогда
			Аргументы = ПустойМассив;
		Иначе
			Аргументы = РазобратьАргументы();
		КонецЕсли;
		Ожидается(Токены.ПраваяКруглаяСкобка);
		СледующийТокен();
		Если Не Парсер_Методы.Свойство(Имя, Объект) Тогда
			Если Не Парсер_Неизвестные.Свойство(Имя, Объект) Тогда
				Объект = Объект(Имя);
				Парсер_Неизвестные.Вставить(Имя, Объект);
			КонецЕсли;
		КонецЕсли;
		Вызов = Истина;
	Иначе
		Объект = НайтиОбъект(Имя);
		Если Объект = Неопределено Тогда
			Если РазрешитьНовуюПеременную Тогда
				Объект = Объект(Имя, ОбъявлениеАвтоПеременной(АвтоМесто));
				НоваяПеременная = Объект;
			Иначе
				Объект = Объект(Имя);
				Если БолтливыйРежим Тогда
					Ошибка(СтрШаблон("Необъявленный идентификатор `%1`", Имя), Позиция);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Вызов = Ложь;
	КонецЕсли;
	Хвост = РазобратьХвост(Вызов);
	Возврат ВыражениеИдентификатор(Объект, Хвост, Аргументы, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьВыражениеИдентификатор()

Функция РазобратьХвост(Вызов = Неопределено)
	Перем Хвост, Имя, Аргументы, Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Хвост = Новый Массив;
	Пока Истина Цикл
		Если Парсер_Токен = Токены.Точка Тогда
			СледующийТокен();
			Если КартаБуквЦифр[Лев(Парсер_Литерал, 1)] <> Буква Или Не КлючевыеСлова.Свойство(Парсер_Литерал) Тогда
				Ожидается(Токены.Идентификатор);
			КонецЕсли;
			Имя = Парсер_Литерал;
			Если СледующийТокен() = Токены.ЛеваяКруглаяСкобка Тогда
				Если СледующийТокен() = Токены.ПраваяКруглаяСкобка Тогда
					Аргументы = ПустойМассив;
				Иначе
					Аргументы = РазобратьАргументы();
				КонецЕсли;
				Ожидается(Токены.ПраваяКруглаяСкобка);
				СледующийТокен();
				Вызов = Истина;
			Иначе
				Аргументы = Неопределено;
				Вызов = Ложь;
			КонецЕсли;
			Хвост.Добавить(ВыражениеПоле(Имя, Аргументы, Место(Позиция, НомерСтроки)));
		ИначеЕсли Парсер_Токен = Токены.ЛеваяКвадратнаяСкобка Тогда
			Вызов = Ложь;
			Если СледующийТокен() = Токены.ПраваяКвадратнаяСкобка Тогда
				Ошибка("Ожидается выражение", Позиция, Истина);
			КонецЕсли;
			Выражение = РазобратьВыражение();
			Ожидается(Токены.ПраваяКвадратнаяСкобка);
			СледующийТокен();
			Хвост.Добавить(ВыражениеИндекс(Выражение, Место(Позиция, НомерСтроки)));
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат Хвост;
КонецФункции // РазобратьХвост()

Функция РазобратьАргументы()
	Перем ВыражениеСписок;
	ВыражениеСписок = Новый Массив;
	Пока Истина Цикл
		Если ТокеныНачалаВыражения.Найти(Парсер_Токен) <> Неопределено Тогда
			ВыражениеСписок.Добавить(РазобратьВыражение());
		Иначе
			ВыражениеСписок.Добавить(Неопределено);
		КонецЕсли;
		Если Парсер_Токен = Токены.Запятая Тогда
			СледующийТокен();
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат ВыражениеСписок;
КонецФункции // РазобратьАргументы()

Функция РазобратьВыражениеТернарное()
	Перем Условие, ТогдаЧасть, ИначеЧасть, Хвост, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Ожидается(Токены.ЛеваяКруглаяСкобка);
	СледующийТокен();
	Условие = РазобратьВыражение();
	Ожидается(Токены.Запятая);
	СледующийТокен();
	ТогдаЧасть = РазобратьВыражение();
	Ожидается(Токены.Запятая);
	СледующийТокен();
	ИначеЧасть = РазобратьВыражение();
	Ожидается(Токены.ПраваяКруглаяСкобка);
	Если СледующийТокен() = Токены.Точка Тогда
		Хвост = РазобратьХвост();
	Иначе
		Хвост = ПустойМассив;
	КонецЕсли;
	Возврат ВыражениеТернарное(Условие, ТогдаЧасть, ИначеЧасть, Хвост, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьВыражениеТернарное()

Функция РазобратьВыражениеСкобки()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидается(Токены.ПраваяКруглаяСкобка);
	СледующийТокен();
	Возврат ВыражениеСкобки(Выражение, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьВыражениеСкобки()

#КонецОбласти // РазборВыражений

#Область РазборОбъявлений

Функция РазобратьОбъявленияМодуля()
	Перем Объявления;
	Объявления = Новый Массив;
	Пока Парсер_Токен = Токены.Директива Цикл
		Парсер_Директива = Парсер_Литерал;//Директивы[Парсер_Литерал];
		Парсер_Токен = СледующийТокен();
	КонецЦикла;
	Пока Истина Цикл
		Если Парсер_Токен = Токены.Перем И Парсер_РазрешеныПерем Тогда
			Объявления.Добавить(РазобратьОбъявлениеСпискаПеременныхУровняМодуля());
		ИначеЕсли Парсер_Токен = Токены.Функция Тогда
			Парсер_ЭтоФункция = Истина;
			Объявления.Добавить(РазобратьОбъявлениеМетода());
			Парсер_ЭтоФункция = Ложь;
			Парсер_РазрешеныПерем = Ложь;
		ИначеЕсли Парсер_Токен = Токены.Процедура Тогда
			Объявления.Добавить(РазобратьОбъявлениеМетода());
			Парсер_РазрешеныПерем = Ложь;
		ИначеЕсли Парсер_Токен = Токены._Область Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораОбласть());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._КонецОбласти Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораКонецОбласти());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._Если Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораЕсли());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._ИначеЕсли Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораИначеЕсли());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._Иначе Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораИначе());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._КонецЕсли Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораКонецЕсли());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._Использовать Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораИспользовать());
		Иначе
			Прервать;
		КонецЕсли;
		Парсер_Директива = Неопределено;
		Пока Парсер_Токен = Токены.Директива Цикл
			Парсер_Директива = Парсер_Литерал;//Директивы[Парсер_Литерал];
			СледующийТокен();
		КонецЦикла;
	КонецЦикла;
	Возврат Объявления;
КонецФункции // РазобратьОбъявленияМодуля()

Функция РазобратьОбъявлениеСпискаПеременныхУровняМодуля()
	Перем СписокПеременных, Объявление, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	СписокПеременных = Новый Массив;
	СписокПеременных.Добавить(РазобратьОбъявлениеПеременнойУровняМодуля());
	Пока Парсер_Токен = Токены.Запятая Цикл
		СледующийТокен();
		СписокПеременных.Добавить(РазобратьОбъявлениеПеременнойУровняМодуля());
	КонецЦикла;
	Объявление = ОбъявлениеСпискаПеременныхУровняМодуля(Парсер_Директива, СписокПеременных, Место(Позиция, НомерСтроки));
	Ожидается(Токены.ТочкаСЗапятой);
	СледующийТокен();
	Пока Парсер_Токен = Токены.ТочкаСЗапятой Цикл
		СледующийТокен();
	КонецЦикла;
	Возврат Объявление;
КонецФункции // РазобратьОбъявлениеСпискаПеременныхУровняМодуля()

Функция РазобратьОбъявлениеПеременнойУровняМодуля()
	Перем Имя, ОбъявлениеПеременнойУровняМодуля, Экспортировано, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Ожидается(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	Если СледующийТокен() = Токены.Экспорт Тогда
		Экспортировано = Истина;
		СледующийТокен();
	Иначе
		Экспортировано = Ложь;
	КонецЕсли;
	ОбъявлениеПеременнойУровняМодуля = ОбъявлениеПеременнойУровняМодуля(Имя, Парсер_Директива, Экспортировано, Место(Позиция, НомерСтроки));
	Если Экспортировано Тогда
		Парсер_ПрограммныйИнтерфейс.Добавить(ОбъявлениеПеременнойУровняМодуля);
	КонецЕсли;
	Если Парсер_Переменные.Свойство(Имя) Тогда
		Ошибка("Идентификатор уже объявлен", Позиция, Истина);
	КонецЕсли;
	Парсер_Переменные.Вставить(Имя, Объект(Имя, ОбъявлениеПеременнойУровняМодуля));
	Возврат ОбъявлениеПеременнойУровняМодуля;
КонецФункции // РазобратьОбъявлениеПеременнойУровняМодуля()

Функция РазобратьПеременные()
	Перем Токен, Объявления;
	Объявления = Новый Массив;
	Токен = Парсер_Токен;
	Пока Токен = Токены.Перем Цикл
		СледующийТокен();
		Объявления.Добавить(РазобратьОбъявлениеЛокальнойПеременной());
		Пока Парсер_Токен = Токены.Запятая Цикл
			СледующийТокен();
			Объявления.Добавить(РазобратьОбъявлениеЛокальнойПеременной());
		КонецЦикла;
		Ожидается(Токены.ТочкаСЗапятой);
		Токен = СледующийТокен();
	КонецЦикла;
	Возврат Объявления;
КонецФункции // РазобратьПеременные()

Функция РазобратьОбъявлениеЛокальнойПеременной()
	Перем Имя, ОбъявлениеЛокальнойПеременной, Позиция;
	Позиция = Парсер_ПозицияНачала;
	Ожидается(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	ОбъявлениеЛокальнойПеременной = ОбъявлениеЛокальнойПеременной(Имя, Место());
	Если Парсер_Переменные.Свойство(Имя) Тогда
		Ошибка("Идентификатор уже объявлен", Позиция, Истина);
	КонецЕсли;
	Парсер_Переменные.Вставить(Имя, Объект(Имя, ОбъявлениеЛокальнойПеременной));
	СледующийТокен();
	Возврат ОбъявлениеЛокальнойПеременной;
КонецФункции // РазобратьОбъявлениеЛокальнойПеременной()

Функция РазобратьОбъявлениеМетода()
	Перем Сигнатура, Объект, Имя, Переменные, Параметры, Экспортировано, Инструкции, Авто, ОбъектПеременной, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Экспортировано = Ложь;
	СледующийТокен();
	Ожидается(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	СледующийТокен();
	ОткрытьОкружение();
	Параметры = РазобратьПараметры();
	Если Парсер_Токен = Токены.Экспорт Тогда
		Экспортировано = Истина;
		СледующийТокен();
	КонецЕсли;
	Если Парсер_ЭтоФункция Тогда
		Сигнатура = СигнатураФункции(Имя, Парсер_Директива, Параметры, Экспортировано, Место(Позиция, НомерСтроки));
	Иначе
		Сигнатура = СигнатураПроцедуры(Имя, Парсер_Директива, Параметры, Экспортировано, Место(Позиция, НомерСтроки));
	КонецЕсли;
	Если Парсер_Неизвестные.Свойство(Имя, Объект) Тогда
		Парсер_Неизвестные.Delete(Имя);
		Объект.Объявление = Сигнатура;
	Иначе
		Объект = Объект(Имя, Сигнатура);
	КонецЕсли;
	Если Парсер_Методы.Свойство(Имя) Тогда
		Ошибка("Метод уже объявлен", Позиция, Истина);
	КонецЕсли;
	Парсер_Методы.Вставить(Имя, Объект);
	Если Экспортировано Тогда
		Парсер_ПрограммныйИнтерфейс.Добавить(Объект);
	КонецЕсли;
	Переменные = РазобратьПеременные();
	Инструкции = РазобратьИнструкции();
	Если Парсер_ЭтоФункция Тогда
		Ожидается(Токены.КонецФункции);
	Иначе
		Ожидается(Токены.КонецПроцедуры);
	КонецЕсли;
	Авто = Новый Массив;
	Для Каждого ОбъектПеременной Из Парсер_Окружение.Авто Цикл
		Авто.Добавить(ОбъектПеременной);
	КонецЦикла;
	ЗакрытьОкружение();
	СледующийТокен();
	Возврат ОбъявлениеМетода(Сигнатура, Переменные, Авто, Инструкции, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьОбъявлениеМетода()

Функция РазобратьПараметры()
	Перем Параметры;
	Ожидается(Токены.ЛеваяКруглаяСкобка);
	СледующийТокен();
	Если Парсер_Токен = Токены.ПраваяКруглаяСкобка Тогда
		Параметры = ПустойМассив;
	Иначе
		Параметры = Новый Массив;
		Параметры.Добавить(РазобратьОбъявлениеПараметра());
		Пока Парсер_Токен = Токены.Запятая Цикл
			СледующийТокен();
			Параметры.Добавить(РазобратьОбъявлениеПараметра());
		КонецЦикла;
	КонецЕсли;
	Ожидается(Токены.ПраваяКруглаяСкобка);
	СледующийТокен();
	Возврат Параметры;
КонецФункции // РазобратьПараметры()

Функция РазобратьОбъявлениеПараметра()
	Перем Имя, ОбъявлениеПараметра, ПоЗначению, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Если Парсер_Токен = Токены.Знач Тогда
		ПоЗначению = Истина;
		СледующийТокен();
	Иначе
		ПоЗначению = Ложь;
	КонецЕсли;
	Ожидается(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	Если СледующийТокен() = Токены.Равенство Тогда
		СледующийТокен();
		ОбъявлениеПараметра = ОбъявлениеПараметра(Имя, ПоЗначению, РазобратьВыражениеУнарное(), Место(Позиция, НомерСтроки));
	Иначе
		ОбъявлениеПараметра = ОбъявлениеПараметра(Имя, ПоЗначению, , Место(Позиция, НомерСтроки));
	КонецЕсли;
	Если Парсер_Переменные.Свойство(Имя) Тогда
		Ошибка("Идентификатор уже объявлен", Позиция, Истина);
	КонецЕсли;
	Парсер_Переменные.Вставить(Имя, Объект(Имя, ОбъявлениеПараметра));
	Возврат ОбъявлениеПараметра;
КонецФункции // РазобратьОбъявлениеПараметра()

#КонецОбласти // РазборОбъявлений

#Область РазборИнструкций

Функция РазобратьИнструкции()
	Перем Инструкции, Инструкция;
	Инструкции = Новый Массив;
	Инструкция = РазобратьИнструкцию();
	Если Инструкция <> Неопределено Тогда
		Инструкции.Добавить(Инструкция);
	КонецЕсли;
	Пока Истина Цикл
		Если Парсер_Токен = Токены.ТочкаСЗапятой Тогда
			СледующийТокен();
		ИначеЕсли Лев(Парсер_Токен, 1) <> "_" Тогда
			Прервать;
		КонецЕсли;
		Инструкция = РазобратьИнструкцию();
		Если Инструкция <> Неопределено Тогда
			Инструкции.Добавить(Инструкция);
		КонецЕсли;
	КонецЦикла;
	Возврат Инструкции;
КонецФункции // РазобратьИнструкции()

Функция РазобратьИнструкцию()
	Перем Токен, Инструкция, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Токен = Парсер_Токен;
	Если Токен = Токены.Идентификатор Тогда
		Инструкция = РазобратьПрисваиваниеИлиВызов();
	ИначеЕсли Токен = Токены.Если Тогда
		Инструкция = РазобратьИнструкциюЕсли();
	ИначеЕсли Токен = Токены.Попытка Тогда
		Инструкция = РазобратьИнструкциюПопытка();
	ИначеЕсли Токен = Токены.Пока Тогда
		Инструкция = РазобратьИнструкциюПока();
	ИначеЕсли Токен = Токены.Для Тогда
		Если СледующийТокен() = Токены.Каждого Тогда
			Инструкция = РазобратьИнструкциюДляКаждого();
		Иначе
			Инструкция = РазобратьИнструкциюДля();
		КонецЕсли;
	ИначеЕсли Токен = Токены.Возврат Тогда
		Инструкция = РазобратьИнструкциюВозврат();
	ИначеЕсли Токен = Токены.Прервать Тогда
		Инструкция = РазобратьИнструкциюПрервать();
	ИначеЕсли Токен = Токены.Продолжить Тогда
		Инструкция = РазобратьИнструкциюПродолжить();
	ИначеЕсли Токен = Токены.ВызватьИсключение Тогда
		Инструкция = РазобратьИнструкциюВызватьИсключение();
	ИначеЕсли Токен = Токены.Выполнить Тогда
		Инструкция = РазобратьИнструкциюВыполнить();
	ИначеЕсли Токен = Токены.Перейти Тогда
		Инструкция = РазобратьИнструкциюПерейти();
	ИначеЕсли Токен = Токены.Метка Тогда
		Инструкция = РазобратьИнструкциюМетка();
	ИначеЕсли Токен = Токены._Область Тогда
		Инструкция = РазобратьИнструкциюПрепроцессораОбласть();
	ИначеЕсли Токен = Токены._КонецОбласти Тогда
		Инструкция = РазобратьИнструкциюПрепроцессораКонецОбласти();
	ИначеЕсли Токен = Токены._Если Тогда
		Инструкция = РазобратьИнструкциюПрепроцессораЕсли();
	ИначеЕсли Токен = Токены._ИначеЕсли Тогда
		Инструкция = РазобратьИнструкциюПрепроцессораИначеЕсли();
	ИначеЕсли Токен = Токены._Иначе Тогда
		Инструкция = РазобратьИнструкциюПрепроцессораИначе();
	ИначеЕсли Токен = Токены._КонецЕсли Тогда
		Инструкция = РазобратьИнструкциюПрепроцессораКонецЕсли();
	ИначеЕсли Токен = Токены.ТочкаСЗапятой Тогда
		// пропуск
	КонецЕсли;
	Возврат Инструкция;
КонецФункции // РазобратьИнструкцию()

Функция РазобратьИнструкциюВызватьИсключение()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Если ТокеныНачалаВыражения.Найти(СледующийТокен()) <> Неопределено Тогда
		Выражение = РазобратьВыражение();
	КонецЕсли;
	Возврат ИнструкцияВызватьИсключение(Выражение, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюВызватьИсключение()

Функция РазобратьИнструкциюВыполнить()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Возврат ИнструкцияВыполнить(РазобратьВыражение(), Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюВыполнить()

Функция РазобратьПрисваиваниеИлиВызов()
	Перем Левый, Вызов, Правый, Инструкция, НоваяПеременная, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Левый = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, Вызов);
	Если Вызов Тогда
		Инструкция = ИнструкцияВызвать(Левый, Место(Позиция, НомерСтроки));
	Иначе
		Ожидается(Токены.Равенство);
		СледующийТокен();
		Правый = РазобратьВыражение();
		Если НоваяПеременная <> Неопределено Тогда
			Парсер_Переменные.Вставить(НоваяПеременная.Имя, НоваяПеременная);
			Парсер_Окружение.Авто.Добавить(НоваяПеременная);
		КонецЕсли;
		Инструкция = ИнструкцияПрисваивания(Левый, Правый, Место(Позиция, НомерСтроки));
	КонецЕсли;
	Возврат Инструкция;
КонецФункции // РазобратьПрисваиваниеИлиВызов()

Функция РазобратьИнструкциюЕсли()
	Перем Условие, ТогдаЧасть, ИначеЧасть, ИначеЕслиЧасть, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Условие = РазобратьВыражение();
	Ожидается(Токены.Тогда);
	СледующийТокен();
	ТогдаЧасть = РазобратьИнструкции();
	Если Парсер_Токен = Токены.ИначеЕсли Тогда
		ИначеЕслиЧасть = Новый Массив;
		Пока Парсер_Токен = Токены.ИначеЕсли Цикл
			ИначеЕслиЧасть.Добавить(РазобратьИнструкциюИначеЕсли());
		КонецЦикла;
	КонецЕсли;
	Если Парсер_Токен = Токены.Иначе Тогда
		ИначеЧасть = РазобратьИнструкциюИначе();
	КонецЕсли;
	Ожидается(Токены.КонецЕсли);
	СледующийТокен();
	Возврат ИнструкцияЕсли(Условие, ТогдаЧасть, ИначеЕслиЧасть, ИначеЧасть, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюЕсли()

Функция РазобратьИнструкциюИначеЕсли()
	Перем ИначеЕслиУсловие, ИначеЕслиТогда, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	ИначеЕслиУсловие = РазобратьВыражение();
	Ожидается(Токены.Тогда);
	СледующийТокен();
	ИначеЕслиТогда = РазобратьИнструкции();
	Возврат ИнструкцияИначеЕсли(ИначеЕслиУсловие, ИначеЕслиТогда, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюИначеЕсли()

Функция РазобратьИнструкциюИначе()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Возврат ИнструкцияИначе(РазобратьИнструкции(), Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюИначе()

Функция РазобратьИнструкциюПопытка()
	Перем ПопыткаЧасть, ИсключениеЧасть, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	ПопыткаЧасть = РазобратьИнструкции();
	Ожидается(Токены.Исключение);
	ИсключениеЧасть = РазобратьИнструкциюИсключение();
	Ожидается(Токены.КонецПопытки);
	СледующийТокен();
	Возврат ИнструкцияПопытка(ПопыткаЧасть, ИсключениеЧасть, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюПопытка()

Функция РазобратьИнструкциюИсключение()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Возврат ИнструкцияИсключение(РазобратьИнструкции(), Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюИсключение()

Функция РазобратьИнструкциюПока()
	Перем Условие, Инструкции, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Условие = РазобратьВыражение();
	Ожидается(Токены.Цикл);
	СледующийТокен();
	Инструкции = РазобратьИнструкции();
	Ожидается(Токены.КонецЦикла);
	СледующийТокен();
	Возврат ИнструкцияПока(Условие, Инструкции, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюПока()

Функция РазобратьИнструкциюДля()
	Перем ВыражениеИдентификатор, Вызов, НачинаяС, До, Инструкции, ПеремПозиция, НоваяПеременная, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Ожидается(Токены.Идентификатор);
	ПеремПозиция = Парсер_ПозицияНачала;
	ВыражениеИдентификатор = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, Вызов);
	Если Вызов Тогда
		Ошибка("Ожидается переменная", ПеремПозиция, Истина);
	КонецЕсли;
	Ожидается(Токены.Равенство);
	СледующийТокен();
	НачинаяС = РазобратьВыражение();
	Ожидается(Токены.По);
	СледующийТокен();
	До = РазобратьВыражение();
	Если НоваяПеременная <> Неопределено Тогда
		Парсер_Переменные.Вставить(НоваяПеременная.Имя, НоваяПеременная);
		Парсер_Окружение.Авто.Добавить(НоваяПеременная);
	КонецЕсли;
	Ожидается(Токены.Цикл);
	СледующийТокен();
	Инструкции = РазобратьИнструкции();
	Ожидается(Токены.КонецЦикла);
	СледующийТокен();
	Возврат ИнструкцияДля(ВыражениеИдентификатор, НачинаяС, До, Инструкции, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюДля()

Функция РазобратьИнструкциюДляКаждого()
	Перем ВыражениеИдентификатор, Вызов, Коллекция, Инструкции, ПеремПозиция, НоваяПеременная, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Ожидается(Токены.Идентификатор);
	ПеремПозиция = Парсер_ПозицияНачала;
	ВыражениеИдентификатор = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, Вызов);
	Если Вызов Тогда
		Ошибка("Ожидается переменная", ПеремПозиция, Истина);
	КонецЕсли;
	Ожидается(Токены.Из);
	СледующийТокен();
	Коллекция = РазобратьВыражение();
	Если НоваяПеременная <> Неопределено Тогда
		Парсер_Переменные.Вставить(НоваяПеременная.Имя, НоваяПеременная);
		Парсер_Окружение.Авто.Добавить(НоваяПеременная);
	КонецЕсли;
	Ожидается(Токены.Цикл);
	СледующийТокен();
	Инструкции = РазобратьИнструкции();
	Ожидается(Токены.КонецЦикла);
	СледующийТокен();
	Возврат ИнструкцияДляКаждого(ВыражениеИдентификатор, Коллекция, Инструкции, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюДляКаждого()

Функция РазобратьИнструкциюПерейти()
	Перем Метка, Позиция, НомерСтроки;
	СледующийТокен();
	Ожидается(Токены.Метка);
	Метка = Парсер_Литерал;
	СледующийТокен();
	Возврат ИнструкцияПерейти(Метка, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюПерейти()

Функция РазобратьИнструкциюВозврат()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Если Парсер_ЭтоФункция Тогда
		Выражение = РазобратьВыражение();
	КонецЕсли;
	Возврат ИнструкцияВозврат(Выражение, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюВозврат()

Функция РазобратьИнструкциюПрервать()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Возврат ИнструкцияПрервать(Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюПрервать()

Функция РазобратьИнструкциюПродолжить()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Возврат ИнструкцияПродолжить(Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюПродолжить()

Функция РазобратьИнструкциюМетка()
	Перем Позиция, НомерСтроки, Метка;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Метка = Парсер_Литерал;
	СледующийТокен();
	Ожидается(Токены.Двоеточие);
	Парсер_Токен = Токены.ТочкаСЗапятой; // лазейка
	Возврат ИнструкцияМетка(Метка, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюМетка()

#КонецОбласти // РазборИнструкций

#Область РазборПрепроцессора

// Выражения

Функция РазобратьВыражениеПрепроцессора()
	Перем Выражение, Оператор, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Выражение = РазобратьВыражениеПрепроцессораИ();
	Пока Парсер_Токен = Токены.Или Цикл
		Оператор = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеПрепроцессораБинарное(Выражение, Оператор, РазобратьВыражениеПрепроцессораИ(), Место(Позиция, НомерСтроки));
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеПрепроцессора()

Функция РазобратьВыражениеПрепроцессораИ()
	Перем Выражение, Оператор, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Выражение = РазобратьВыражениеПрепроцессораНе();
	Пока Парсер_Токен = Токены.И Цикл
		Оператор = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеПрепроцессораБинарное(Выражение, Оператор, РазобратьВыражениеПрепроцессораНе(), Место(Позиция, НомерСтроки));
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеПрепроцессораИ()

Функция РазобратьВыражениеПрепроцессораНе()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Если Парсер_Токен = Токены.Не Тогда
		СледующийТокен();
		Выражение = ВыражениеПрепроцессораНе(РазобратьВыражениеПрепроцессораСимвол(), Место(Позиция, НомерСтроки));
	Иначе
		Выражение = РазобратьВыражениеПрепроцессораСимвол();
	КонецЕсли;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеПрепроцессораНе()

Функция РазобратьВыражениеПрепроцессораСимвол()
	Перем Операнд, СимволСуществует;
	Если Парсер_Токен = Токены.Идентификатор Тогда
		СимволСуществует = СимволыПрепроцессора.Свойство(Парсер_Литерал);
		Операнд = ВыражениеПрепроцессораСимвол(Парсер_Литерал, СимволСуществует, Место());
		СледующийТокен();
	Иначе
		Ошибка("Ожидается символ препроцессора", , Истина);
	КонецЕсли;
	Возврат Операнд;
КонецФункции // РазобратьВыражениеПрепроцессораСимвол()

// Инструкции

Функция РазобратьИнструкциюПрепроцессораИспользовать()
	Перем Путь, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Если НомерСтроки <> Парсер_ТекущийНомерСтроки Тогда
		Ошибка("Ожидается строка или идентификатор", Парсер_ПозицияОкончания, Истина);
	КонецЕсли;
	Если Парсер_Токен = Токены.Число Тогда
		Путь = Парсер_Литерал;
		Если КартаБуквЦифр[Парсер_Символ] = Буква Тогда  // может быть ключевым словом
			СледующийТокен();
			Путь = Путь + Парсер_Литерал;
		КонецЕсли;
	ИначеЕсли Парсер_Токен = Токены.Идентификатор
		Или Парсер_Токен = Токены.Строка Тогда
		Путь = Парсер_Литерал;
	Иначе
		Ошибка("Ожидается строка или идентификатор", Парсер_ПозицияОкончания, Истина);
	КонецЕсли;
	СледующийТокен();
	Возврат ИнструкцияПрепроцессораИспользовать(Путь, Место(Позиция, НомерСтроки));
КонецФункции // РазобратьИнструкциюПрепроцессораИспользовать()

Функция РазобратьИнструкциюПрепроцессораЕсли()
	Перем Условие, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Условие = РазобратьВыражениеПрепроцессора();
	Ожидается(Токены.Тогда);
	Парсер_Токен = Токены.ТочкаСЗапятой; // лазейка
	Возврат ИнструкцияПрепроцессораЕсли(Условие, Место(Позиция, НомерСтроки, Парсер_ТекущаяПозиция - Позиция));
КонецФункции // РазобратьИнструкциюПрепроцессораЕсли()

Функция РазобратьИнструкциюПрепроцессораИначеЕсли()
	Перем Условие, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Условие = РазобратьВыражениеПрепроцессора();
	Ожидается(Токены.Тогда);
	Парсер_Токен = Токены.ТочкаСЗапятой; // лазейка
	Возврат ИнструкцияПрепроцессораИначеЕсли(Условие, Место(Позиция, НомерСтроки, Парсер_ТекущаяПозиция - Позиция));
КонецФункции // РазобратьИнструкциюПрепроцессораИначеЕсли()

Функция РазобратьИнструкциюПрепроцессораИначе()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Парсер_Токен = Токены.ТочкаСЗапятой; // лазейка
	Возврат ИнструкцияПрепроцессораИначе(Место(Позиция, НомерСтроки, Парсер_ТекущаяПозиция - Позиция));
КонецФункции // РазобратьИнструкциюПрепроцессораИначе()

Функция РазобратьИнструкциюПрепроцессораКонецЕсли()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Парсер_Токен = Токены.ТочкаСЗапятой; // лазейка
	Возврат ИнструкцияПрепроцессораКонецЕсли(Место(Позиция, НомерСтроки, Парсер_ТекущаяПозиция - Позиция));
КонецФункции // РазобратьИнструкциюПрепроцессораКонецЕсли()

Функция РазобратьИнструкциюПрепроцессораОбласть()
	Перем Имя, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	СледующийТокен();
	Ожидается(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	Парсер_Токен = Токены.ТочкаСЗапятой; // лазейка
	Возврат ИнструкцияПрепроцессораОбласть(Имя, Место(Позиция, НомерСтроки, Парсер_ТекущаяПозиция - Позиция));
КонецФункции // РазобратьИнструкциюПрепроцессораОбласть()

Функция РазобратьИнструкциюПрепроцессораКонецОбласти()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_ТекущийНомерСтроки;
	Парсер_Токен = Токены.ТочкаСЗапятой; // лазейка
	Возврат ИнструкцияПрепроцессораКонецОбласти(Место(Позиция, НомерСтроки, Парсер_ТекущаяПозиция - Позиция));
КонецФункции // РазобратьИнструкциюПрепроцессораКонецОбласти()

#КонецОбласти // РазборПрепроцессора

#КонецОбласти // Парсер

#Область Вспомогательное

Функция Место(Позиция = Неопределено, НомерСтроки = Неопределено, Длина = Неопределено)
	Перем Место;
	Если ПоложениеУзлаВАСТ Тогда
		Если Позиция = Неопределено Тогда
			Длина = СтрДлина(Парсер_Литерал);
			Позиция = Парсер_ТекущаяПозиция - Длина;
		ИначеЕсли Длина = Неопределено Тогда
			Длина = Парсер_ПозицияОкончания - Позиция;
		КонецЕсли;
		Если НомерСтроки = Неопределено Тогда
			НомерСтроки = Парсер_ТекущийНомерСтроки;
		КонецЕсли;
		Место = Новый Структура(
			"Позиция,"              // число
			"Длина,"                // число
			"НомерСтрокиНачала,"    // число
			"НомерСтрокиОкончания", // число
			Позиция, Длина, НомерСтроки, Парсер_НомерСтрокиОкончания);
		Если Отладка Тогда
			Место.Вставить("Строка", Сред(Парсер_Исходник, Позиция, Длина));
		КонецЕсли;
	Иначе
		Место = НомерСтроки;
	КонецЕсли;
	Возврат Место;
КонецФункции // Место()

Функция КакДата(ЛитералДаты)
	Перем Список, Символ, Номер, ДатаСтрокой;
	Список = Новый Массив;
	Для Номер = 1 По СтрДлина(ЛитералДаты) Цикл
		Символ = Сред(ЛитералДаты, Номер, 1);
		Если КартаБуквЦифр[Символ] = Цифра Тогда
			Список.Добавить(Символ);
		КонецЕсли;
	КонецЦикла;
	ДатаСтрокой = СтрСоединить(Список);
	Если ДатаСтрокой = "00000000"
		Или ДатаСтрокой = "000000000000"
		Или ДатаСтрокой = "00000000000000" Тогда
		Возврат '00010101';
	КонецЕсли;
	Возврат Дата(ДатаСтрокой);
КонецФункции // КакДата()

Процедура Ожидается(Токен)
	Если Парсер_Токен <> Токен Тогда
		Ошибка("Ожидается " + Токен, , Истина);
	КонецЕсли;
КонецПроцедуры // Ожидается()

Функция ТокенСтроки(Литерал)
	Перем Токен;
	Если Лев(Литерал, 1) = """" Тогда
		Если Прав(Литерал, 1) = """" Тогда
			Токен = Токены.Строка;
		Иначе
			Токен = Токены.СтрокаНачало;
		КонецЕсли;
	Иначе  // |
		Если Прав(Литерал, 1) = """" Тогда
			Токен = Токены.СтрокаОкончание;
		Иначе
			Токен = Токены.СтрокаПродолжение;
		КонецЕсли;
	КонецЕсли;
	Возврат Токен;
КонецФункции // ТокенСтроки()

Процедура Ошибка(Текст, Позиция = Неопределено, Остановить = Ложь)
	Перем ТекстОшибки;
	Если Позиция = Неопределено Тогда
		Позиция = Min(Парсер_ТекущаяПозиция - СтрДлина(Парсер_Литерал), Парсер_Длина);
	КонецЕсли;
	ТекстОшибки = СтрШаблон("[ Стр: %1; Кол: %2 ] %3",
		СтрЧислоВхождений(Сред(Парсер_Исходник, 1, Позиция), ПереводСтроки) + 1,
		Позиция - ?(Позиция = 0, 0, СтрНайти(Парсер_Исходник, ПереводСтроки, НаправлениеПоиска.СКонца, Позиция)),
		Текст
	);
	Если Остановить Тогда
		ВызватьИсключение ТекстОшибки;
	Иначе
		Сообщить(ТекстОшибки);
	КонецЕсли;
КонецПроцедуры // Ошибка()

#КонецОбласти // Вспомогательное

#Область Посетитель

Процедура Подключить(Знач Плагины) Экспорт
	Перем Плагин, Список, ИмяМетода;
	Если ТипЗнч(Плагины) <> Тип("Массив") Тогда
		Плагин = Плагины;
		Плагины = Новый Массив;
		Плагины.Добавить(Плагин);
	КонецЕсли;
	Посетитель_Плагины = Плагины;
	Посетитель_Подписки = Подписки();
	Для Каждого Плагин Из Плагины Цикл
		Список = Неопределено;
		Для Каждого ИмяМетода Из Плагин.Интерфейс() Цикл
			Если Посетитель_Подписки.Свойство(ИмяМетода, Список) Тогда
				Список.Добавить(Плагин);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры // Подключить()

Процедура ЗакинутьИнформациюНаСтек(Родитель)
	Перем ТипУзла;
	Посетитель_Стек = Новый ФиксированнаяСтруктура("Внешний, Родитель", Посетитель_Стек, Родитель);
	ТипУзла = Родитель.Тип;
	Посетитель_Счетчики[ТипУзла] = Посетитель_Счетчики[ТипУзла] + 1;
КонецПроцедуры // ЗакинутьИнформациюНаСтек()

Процедура СнятьИнформациюСоСтека()
	Перем ТипУзла;
	ТипУзла = Посетитель_Стек.Родитель.Тип;
	Посетитель_Счетчики[ТипУзла] = Посетитель_Счетчики[ТипУзла] - 1;
	Посетитель_Стек = Посетитель_Стек.Внешний;
КонецПроцедуры // СнятьИнформациюСоСтека()

Функция Подписки()
	Перем Подписки, Элемент;

	Подписки = Новый Структура(
		"ПосетитьМодуль,                                 ПослеПосещенияМодуль,"
		"ПосетитьОбъявления,                             ПослеПосещенияОбъявления,"
		"ПосетитьИнструкции,                             ПослеПосещенияИнструкции,"
		"ПосетитьОбъявление,                             ПослеПосещенияОбъявления,"
		"ПосетитьОбъявлениеСпискаПеременныхУровняМодуля, ПослеПосещенияОбъявленияСпискаПеременныхУровняМодуля,"
		"ПосетитьОбъявлениеПеременнойУровняМодуля,       ПослеПосещенияОбъявленияПеременнойУровняМодуля,"
		"ПосетитьОбъявлениеЛокальнойПеременной,          ПослеПосещенияОбъявленияЛокальнойПеременной,"
		"ПосетитьОбъявлениеПараметра,                    ПослеПосещенияОбъявленияПараметра,"
		"ПосетитьОбъявлениеМетода,                       ПослеПосещенияОбъявленияМетода,"
		"ПосетитьСигнатуру,                              ПослеПосещенияСигнатуры,"
		"ПосетитьВыражение,                              ПослеПосещенияВыражения,"
		"ПосетитьВыражениеОсновнойЛитерал,               ПослеПосещенияВыраженияОсновнойЛитерал,"
		"ПосетитьВыражениеИдентификатор,                 ПослеПосещенияВыраженияИдентификатор,"
		"ПосетитьВыражениеУнарное,                       ПослеПосещенияВыраженияУнарное,"
		"ПосетитьВыражениеБинарное,                      ПослеПосещенияВыраженияБинарное,"
		"ПосетитьВыражениеНовый,                         ПослеПосещенияВыраженияНовый,"
		"ПосетитьВыражениеТернарное,                     ПослеПосещенияВыраженияТернарное,"
		"ПосетитьВыражениеСкобки,                        ПослеПосещенияВыраженияСкобки,"
		"ПосетитьВыражениеНе,                            ПослеПосещенияВыраженияНе,"
		"ПосетитьВыражениеСтрока,                        ПослеПосещенияВыраженияСтрока,"
		"ПосетитьИнструкцию,                             ПослеПосещенияИнструкции,"
		"ПосетитьИнструкциюПрисваивания,                 ПослеПосещенияИнструкцииПрисваивания,"
		"ПосетитьИнструкциюВозврат,                      ПослеПосещенияИнструкцииВозврат,"
		"ПосетитьИнструкциюПрервать,                     ПослеПосещенияИнструкцииПрервать,"
		"ПосетитьИнструкциюПродолжить,                   ПослеПосещенияИнструкцииПродолжить,"
		"ПосетитьИнструкциюВызватьИсключение,            ПослеПосещенияИнструкцииВызватьИсключение,"
		"ПосетитьИнструкциюВыполнить,                    ПослеПосещенияИнструкцииВыполнить,"
		"ПосетитьИнструкциюВызвать,                      ПослеПосещенияИнструкцииВызвать,"
		"ПосетитьИнструкциюЕсли,                         ПослеПосещенияИнструкцииЕсли,"
		"ПосетитьИнструкциюИначеЕсли,                    ПослеПосещенияИнструкцииИначеЕсли,"
		"ПосетитьИнструкциюИначе,                        ПослеПосещенияИнструкцииИначе,"
		"ПосетитьИнструкциюПока,                         ПослеПосещенияИнструкцииПока,"
		"ПосетитьИнструкциюДля,                          ПослеПосещенияИнструкцииДля,"
		"ПосетитьИнструкциюДляКаждого,                   ПослеПосещенияИнструкцииДляКаждого,"
		"ПосетитьИнструкциюПопытка,                      ПослеПосещенияИнструкцииПопытка,"
		"ПосетитьИнструкциюИсключение,                   ПослеПосещенияИнструкцииИсключение,"
		"ПосетитьИнструкциюПерейти,                      ПослеПосещенияИнструкцииПерейти,"
		"ПосетитьИнструкциюМетка,                        ПослеПосещенияИнструкцииМетка,"
		"ПосетитьИнструкциюПрепроцессора,                ПослеПосещенияИнструкцииПрепроцессора,"
		"ПосетитьВыражениеПрепроцессора,                 ПослеПосещенияВыраженияПрепроцессора,"
		"ПосетитьВыражениеПрепроцессораБинарное,         ПослеПосещенияВыраженияПрепроцессораБинарное,"
		"ПосетитьВыражениеПрепроцессораНе,               ПослеПосещенияВыраженияПрепроцессораНе,"
		"ПосетитьВыражениеПрепроцессораСимвол,           ПослеПосещенияВыраженияПрепроцессораСимвол"
	);
	Для Каждого Элемент Из Подписки Цикл
		Подписки[Элемент.Key] = Новый Массив;
	КонецЦикла;

	Возврат Подписки;

КонецФункции // Подписки()

Процедура ПосетитьМодуль(Модуль) Экспорт
	Перем Плагин, Подписка, Элемент;
	Для Каждого Плагин Из Посетитель_Плагины Цикл
		Плагин.Инициализировать(ЭтотОбъект);
	КонецЦикла;
	Посетитель_Стек = Новый ФиксированнаяСтруктура("Внешний, Родитель", Неопределено, Неопределено);
	Посетитель_Счетчики = Новый Структура;
	Для Каждого Элемент Из Узлы Цикл
		Посетитель_Счетчики.Вставить(Элемент.Key, 0);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьМодуль Цикл
		Подписка.ПосетитьМодуль(Модуль, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(Модуль);
	ПосетитьОбъявления(Модуль.Объявления);
	ПосетитьИнструкции(Модуль.Инструкции);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияМодуль Цикл
		Подписка.ПослеПосещенияМодуль(Модуль, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьМодуль()

Процедура ПосетитьОбъявления(Объявления)
	Перем Объявление, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявления Цикл
		Подписка.ПосетитьОбъявления(Объявления, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Объявление Из Объявления Цикл
		ПосетитьОбъявление(Объявление);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияОбъявления Цикл
		Подписка.ПослеПосещенияОбъявления(Объявления, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявления()

Процедура ПосетитьИнструкции(Инструкции)
	Перем Инструкция, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкции Цикл
		Подписка.ПосетитьИнструкции(Инструкции, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Инструкция Из Инструкции Цикл
		ПосетитьИнструкцию(Инструкция);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкции Цикл
		Подписка.ПослеПосещенияИнструкции(Инструкции, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкции()

#Область ПосещениеОбъявлений

Процедура ПосетитьОбъявление(Объявление)
	Перем Тип, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявление Цикл
		Подписка.ПосетитьОбъявление(Объявление, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Тип = Объявление.Тип;
	// Сообщить("Посещаю тип " + Тип);
	Если Тип = Узлы.ОбъявлениеПеременнойУровняМодуля Тогда
		ПосетитьОбъявлениеПеременнойУровняМодуля(Объявление);
	ИначеЕсли Тип = Узлы.ОбъявлениеСпискаПеременныхУровняМодуля Тогда
		ПосетитьОбъявлениеСпискаПеременныхУровняМодуля(Объявление);
	ИначеЕсли Тип = Узлы.ОбъявлениеЛокальнойПеременной Тогда
		ПосетитьОбъявлениеЛокальнойПеременной(Объявление);
	ИначеЕсли Тип = Узлы.ОбъявлениеМетода Тогда
		ПосетитьОбъявлениеМетода(Объявление);
	ИначеЕсли Тип = Узлы.ИнструкцияПрепроцессораОбласть
		Или Тип = Узлы.ИнструкцияПрепроцессораКонецОбласти
		Или Тип = Узлы.ИнструкцияПрепроцессораЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИначеЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИначе
		Или Тип = Узлы.ИнструкцияПрепроцессораКонецЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИспользовать Тогда
		ПосетитьИнструкциюПрепроцессора(Объявление);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияОбъявления Цикл
		Подписка.ПослеПосещенияОбъявления(Объявление, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявление()

Процедура ПосетитьОбъявлениеСпискаПеременныхУровняМодуля(ОбъявлениеСпискаПеременныхУровняМодуля)
	Перем Подписка, ОбъявлениеПеременнойУровняМодуля;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеСпискаПеременныхУровняМодуля Цикл
		Подписка.ПосетитьОбъявлениеСпискаПеременныхУровняМодуля(ОбъявлениеСпискаПеременныхУровняМодуля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ОбъявлениеСпискаПеременныхУровняМодуля);
	Для Каждого ОбъявлениеПеременнойУровняМодуля Из ОбъявлениеСпискаПеременныхУровняМодуля.Список Цикл
		ПосетитьОбъявлениеПеременнойУровняМодуля(ОбъявлениеПеременнойУровняМодуля);
	КонецЦикла;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияОбъявленияСпискаПеременныхУровняМодуля Цикл
		Подписка.ПослеПосещенияОбъявленияСпискаПеременныхУровняМодуля(ОбъявлениеСпискаПеременныхУровняМодуля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеСпискаПеременныхУровняМодуля()

Процедура ПосетитьОбъявлениеПеременнойУровняМодуля(ОбъявлениеПеременнойУровняМодуля)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеПеременнойУровняМодуля Цикл
		Подписка.ПосетитьОбъявлениеПеременнойУровняМодуля(ОбъявлениеПеременнойУровняМодуля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияОбъявленияПеременнойУровняМодуля Цикл
		Подписка.ПослеПосещенияОбъявленияПеременнойУровняМодуля(ОбъявлениеПеременнойУровняМодуля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеПеременнойУровняМодуля()

Процедура ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеЛокальнойПеременной Цикл
		Подписка.ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияОбъявленияЛокальнойПеременной Цикл
		Подписка.ПослеПосещенияОбъявленияЛокальнойПеременной(ОбъявлениеЛокальнойПеременной, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеЛокальнойПеременной()

Процедура ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеПараметра Цикл
		Подписка.ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияОбъявленияПараметра Цикл
		Подписка.ПослеПосещенияОбъявленияПараметра(ОбъявлениеПараметра, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеПараметра()

Процедура ПосетитьОбъявлениеМетода(ОбъявлениеМетода)
	Перем Подписка, ОбъявлениеЛокальнойПеременной;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеМетода Цикл
		Подписка.ПосетитьОбъявлениеМетода(ОбъявлениеМетода, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ОбъявлениеМетода);
	ПосетитьСигнатуру(ОбъявлениеМетода.Сигнатура);
	Для Каждого ОбъявлениеЛокальнойПеременной Из ОбъявлениеМетода.Переменные Цикл
		ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной);
	КонецЦикла;
	ПосетитьИнструкции(ОбъявлениеМетода.Инструкции);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияОбъявленияМетода Цикл
		Подписка.ПослеПосещенияОбъявленияМетода(ОбъявлениеМетода, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеМетода()

Процедура ПосетитьСигнатуру(Сигнатура)
	Перем Подписка, ОбъявлениеПараметра;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьСигнатуру Цикл
		Подписка.ПосетитьСигнатуру(Сигнатура, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(Сигнатура);
	Для Каждого ОбъявлениеПараметра Из Сигнатура.Параметры Цикл
		ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра);
	КонецЦикла;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияСигнатуры Цикл
		Подписка.ПослеПосещенияСигнатуры(Сигнатура, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьСигнатуру()

#КонецОбласти // ПосещениеОбъявлений

#Область ПосещениеВыражений

Процедура ПосетитьВыражение(Выражение)
	Перем Тип, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражение Цикл
		Подписка.ПосетитьВыражение(Выражение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Тип = Выражение.Тип;
	Если Тип = Узлы.ВыражениеОсновнойЛитерал Тогда
		ПосетитьВыражениеОсновнойЛитерал(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеИдентификатор Тогда
		ПосетитьВыражениеИдентификатор(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеУнарное Тогда
		ПосетитьВыражениеУнарное(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеБинарное Тогда
		ПосетитьВыражениеБинарное(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеНовый Тогда
		ПосетитьВыражениеНовый(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеТернарное Тогда
		ПосетитьВыражениеТернарное(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеСкобки Тогда
		ПосетитьВыражениеСкобки(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеНе Тогда
		ПосетитьВыражениеНе(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеСтрока Тогда
		ПосетитьВыражениеСтрока(Выражение);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыражения Цикл
		Подписка.ПослеПосещенияВыражения(Выражение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражение()

Процедура ПосетитьВыражениеОсновнойЛитерал(ВыражениеОсновнойЛитерал)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеОсновнойЛитерал Цикл
		Подписка.ПосетитьВыражениеОсновнойЛитерал(ВыражениеОсновнойЛитерал, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияОсновнойЛитерал Цикл
		Подписка.ПослеПосещенияВыраженияОсновнойЛитерал(ВыражениеОсновнойЛитерал, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеОсновнойЛитерал()

Процедура ПосетитьВыражениеИдентификатор(ВыражениеИдентификатор)
	Перем Элемент, Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеИдентификатор Цикл
		Подписка.ПосетитьВыражениеИдентификатор(ВыражениеИдентификатор, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеИдентификатор);
	Если ВыражениеИдентификатор.Аргументы <> Неопределено Тогда
		Для Каждого Выражение Из ВыражениеИдентификатор.Аргументы Цикл
			Если Выражение <> Неопределено Тогда
				ПосетитьВыражение(Выражение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Для Каждого Элемент Из ВыражениеИдентификатор.Хвост Цикл
		Если Элемент.Тип = Узлы.ВыражениеПоле Тогда
			Если Элемент.Аргументы <> Неопределено Тогда
				Для Каждого Выражение Из Элемент.Аргументы Цикл
					Если Выражение <> Неопределено Тогда
						ПосетитьВыражение(Выражение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли Элемент.Тип = Узлы.ВыражениеИндекс Тогда
			ПосетитьВыражение(Элемент.Выражение);
		Иначе
			ВызватьИсключение "Вызов с нарушением протокола";
		КонецЕсли;
	КонецЦикла;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияИдентификатор Цикл
		Подписка.ПослеПосещенияВыраженияИдентификатор(ВыражениеИдентификатор, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеИдентификатор()

Процедура ПосетитьВыражениеУнарное(ВыражениеУнарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеУнарное Цикл
		Подписка.ПосетитьВыражениеУнарное(ВыражениеУнарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеУнарное);
	ПосетитьВыражение(ВыражениеУнарное.Операнд);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияУнарное Цикл
		Подписка.ПослеПосещенияВыраженияУнарное(ВыражениеУнарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеУнарное()

Процедура ПосетитьВыражениеБинарное(ВыражениеБинарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеБинарное Цикл
		Подписка.ПосетитьВыражениеБинарное(ВыражениеБинарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеБинарное);
	ПосетитьВыражение(ВыражениеБинарное.Левый);
	ПосетитьВыражение(ВыражениеБинарное.Правый);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияБинарное Цикл
		Подписка.ПослеПосещенияВыраженияБинарное(ВыражениеБинарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеБинарное()

Процедура ПосетитьВыражениеНовый(ВыражениеНовый)
	Перем Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеНовый Цикл
		Подписка.ПосетитьВыражениеНовый(ВыражениеНовый, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеНовый);
	Для Каждого Выражение Из ВыражениеНовый.Аргументы Цикл
		Если Выражение <> Неопределено Тогда
			ПосетитьВыражение(Выражение);
		КонецЕсли;
	КонецЦикла;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияНовый Цикл
		Подписка.ПослеПосещенияВыраженияНовый(ВыражениеНовый, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеНовый()

Процедура ПосетитьВыражениеТернарное(ВыражениеТернарное)
	Перем Элемент, Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеТернарное Цикл
		Подписка.ПосетитьВыражениеТернарное(ВыражениеТернарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеТернарное);
	ПосетитьВыражение(ВыражениеТернарное.Условие);
	ПосетитьВыражение(ВыражениеТернарное.Тогда);
	ПосетитьВыражение(ВыражениеТернарное.Иначе);
	Для Каждого Элемент Из ВыражениеТернарное.Хвост Цикл
		Если Элемент.Тип = Узлы.ВыражениеПоле Тогда
			Если Элемент.Аргументы <> Неопределено Тогда
				Для Каждого Выражение Из Элемент.Аргументы Цикл
					Если Выражение <> Неопределено Тогда
						ПосетитьВыражение(Выражение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли Элемент.Тип = Узлы.ВыражениеИндекс Тогда
			ПосетитьВыражение(Элемент.Выражение);
		Иначе
			ВызватьИсключение "Вызов с нарушением протокола";
		КонецЕсли;
	КонецЦикла;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияТернарное Цикл
		Подписка.ПослеПосещенияВыраженияТернарное(ВыражениеТернарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеТернарное()

Процедура ПосетитьВыражениеСкобки(ВыражениеСкобки)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеСкобки Цикл
		Подписка.ПосетитьВыражениеСкобки(ВыражениеСкобки, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеСкобки);
	ПосетитьВыражение(ВыражениеСкобки.Выражение);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияСкобки Цикл
		Подписка.ПослеПосещенияВыраженияСкобки(ВыражениеСкобки, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеСкобки()

Процедура ПосетитьВыражениеНе(ВыражениеНе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеНе Цикл
		Подписка.ПосетитьВыражениеНе(ВыражениеНе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеНе);
	ПосетитьВыражение(ВыражениеНе.Выражение);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияНе Цикл
		Подписка.ПослеПосещенияВыраженияНе(ВыражениеНе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеНе()

Процедура ПосетитьВыражениеСтрока(ВыражениеСтрока)
	Перем Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеСтрока Цикл
		Подписка.ПосетитьВыражениеСтрока(ВыражениеСтрока, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеСтрока);
	Для Каждого Выражение Из ВыражениеСтрока.Список Цикл
		ПосетитьВыражениеОсновнойЛитерал(Выражение);
	КонецЦикла;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияСтрока Цикл
		Подписка.ПослеПосещенияВыраженияСтрока(ВыражениеСтрока, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеСтрока()

#КонецОбласти // ПосещениеВыражений

#Область ПосещениеИнструкций

Процедура ПосетитьИнструкцию(Инструкция)
	Перем Тип, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкцию Цикл
		Подписка.ПосетитьИнструкцию(Инструкция, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Тип = Инструкция.Тип;
	Если Тип = Узлы.ИнструкцияПрисваивания Тогда
		ПосетитьИнструкциюПрисваивания(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияВозврат Тогда
		ПосетитьИнструкциюВозврат(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияПрервать Тогда
		ПосетитьИнструкциюПрервать(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияПродолжить Тогда
		ПосетитьИнструкциюПродолжить(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияВызватьИсключение Тогда
		ПосетитьИнструкциюВызватьИсключение(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияВыполнить Тогда
		ПосетитьИнструкциюВыполнить(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияВызвать Тогда
		ПосетитьИнструкциюВызвать(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияЕсли Тогда
		ПосетитьИнструкциюЕсли(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияПока Тогда
		ПосетитьИнструкциюПока(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияДля Тогда
		ПосетитьИнструкциюДля(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияДляКаждого Тогда
		ПосетитьИнструкциюДляКаждого(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияПопытка Тогда
		ПосетитьИнструкциюПопытка(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияПерейти Тогда
		ПосетитьИнструкциюПерейти(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияМетка Тогда
		ПосетитьИнструкциюМетка(Инструкция);
	ИначеЕсли Тип = Узлы.ИнструкцияПрепроцессораОбласть
		Или Тип = Узлы.ИнструкцияПрепроцессораКонецОбласти
		Или Тип = Узлы.ИнструкцияПрепроцессораЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИначеЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИначе
		Или Тип = Узлы.ИнструкцияПрепроцессораКонецЕсли Тогда
		ПосетитьИнструкциюПрепроцессора(Инструкция);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкции Цикл
		Подписка.ПослеПосещенияИнструкции(Инструкция, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкцию()

Процедура ПосетитьИнструкциюПрисваивания(ИнструкцияПрисваивания)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПрисваивания Цикл
		Подписка.ПосетитьИнструкциюПрисваивания(ИнструкцияПрисваивания, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияПрисваивания);
	ПосетитьВыражениеИдентификатор(ИнструкцияПрисваивания.Левый);
	ПосетитьВыражение(ИнструкцияПрисваивания.Правый);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииПрисваивания Цикл
		Подписка.ПослеПосещенияИнструкцииПрисваивания(ИнструкцияПрисваивания, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюПрисваивания()

Процедура ПосетитьИнструкциюВозврат(ИнструкцияВозврат)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюВозврат Цикл
		Подписка.ПосетитьИнструкциюВозврат(ИнструкцияВозврат, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияВозврат);
	Если ИнструкцияВозврат.Выражение <> Неопределено Тогда
		ПосетитьВыражение(ИнструкцияВозврат.Выражение);
	КонецЕсли;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииВозврат Цикл
		Подписка.ПослеПосещенияИнструкцииВозврат(ИнструкцияВозврат, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюВозврат()

Процедура ПосетитьИнструкциюПрервать(ИнструкцияПрервать)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПрервать Цикл
		Подписка.ПосетитьИнструкциюПрервать(ИнструкцияПрервать, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииПрервать Цикл
		Подписка.ПослеПосещенияИнструкцииПрервать(ИнструкцияПрервать, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюПрервать()

Процедура ПосетитьИнструкциюПродолжить(ИнструкцияПродолжить)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПродолжить Цикл
		Подписка.ПосетитьИнструкциюПродолжить(ИнструкцияПродолжить, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииПродолжить Цикл
		Подписка.ПослеПосещенияИнструкцииПродолжить(ИнструкцияПродолжить, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюПродолжить()

Процедура ПосетитьИнструкциюВызватьИсключение(ИнструкцияВызватьИсключение)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюВызватьИсключение Цикл
		Подписка.ПосетитьИнструкциюВызватьИсключение(ИнструкцияВызватьИсключение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияВызватьИсключение);
	Если ИнструкцияВызватьИсключение.Выражение <> Неопределено Тогда
		ПосетитьВыражение(ИнструкцияВызватьИсключение.Выражение);
	КонецЕсли;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииВызватьИсключение Цикл
		Подписка.ПослеПосещенияИнструкцииВызватьИсключение(ИнструкцияВызватьИсключение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюВызватьИсключение()

Процедура ПосетитьИнструкциюВыполнить(ИнструкцияВыполнить)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюВыполнить Цикл
		Подписка.ПосетитьИнструкциюВыполнить(ИнструкцияВыполнить, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияВыполнить);
	ПосетитьВыражение(ИнструкцияВыполнить.Выражение);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииВыполнить Цикл
		Подписка.ПослеПосещенияИнструкцииВыполнить(ИнструкцияВыполнить, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюВыполнить()

Процедура ПосетитьИнструкциюВызвать(ИнструкцияВызвать)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюВызвать Цикл
		Подписка.ПосетитьИнструкциюВызвать(ИнструкцияВызвать, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияВызвать);
	ПосетитьВыражениеИдентификатор(ИнструкцияВызвать.Идентификатор);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииВызвать Цикл
		Подписка.ПослеПосещенияИнструкцииВызвать(ИнструкцияВызвать, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюВызвать()

Процедура ПосетитьИнструкциюЕсли(ИнструкцияЕсли)
	Перем ИнструкцияИначеЕсли, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюЕсли Цикл
		Подписка.ПосетитьИнструкциюЕсли(ИнструкцияЕсли, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияЕсли);
	ПосетитьВыражение(ИнструкцияЕсли.Условие);
	ПосетитьИнструкции(ИнструкцияЕсли.Тогда);
	Если ИнструкцияЕсли.ИначеЕсли <> Неопределено Тогда
		Для Каждого ИнструкцияИначеЕсли Из ИнструкцияЕсли.ИначеЕсли Цикл
			ПосетитьИнструкциюИначеЕсли(ИнструкцияИначеЕсли);
		КонецЦикла;
	КонецЕсли;
	Если ИнструкцияЕсли.Иначе <> Неопределено Тогда
		ПосетитьИнструкциюИначе(ИнструкцияЕсли.Иначе);
	КонецЕсли;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииЕсли Цикл
		Подписка.ПослеПосещенияИнструкцииЕсли(ИнструкцияЕсли, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюЕсли()

Процедура ПосетитьИнструкциюИначеЕсли(ИнструкцияИначеЕсли)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюИначеЕсли Цикл
		Подписка.ПосетитьИнструкциюИначеЕсли(ИнструкцияИначеЕсли, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияИначеЕсли);
	ПосетитьВыражение(ИнструкцияИначеЕсли.Условие);
	ПосетитьИнструкции(ИнструкцияИначеЕсли.Тогда);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииИначеЕсли Цикл
		Подписка.ПослеПосещенияИнструкцииИначеЕсли(ИнструкцияИначеЕсли, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюИначеЕсли()

Процедура ПосетитьИнструкциюИначе(ИнструкцияИначе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюИначе Цикл
		Подписка.ПосетитьИнструкциюИначе(ИнструкцияИначе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияИначе);
	ПосетитьИнструкции(ИнструкцияИначе.Инструкции);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииИначе Цикл
		Подписка.ПослеПосещенияИнструкцииИначе(ИнструкцияИначе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюИначе()

Процедура ПосетитьИнструкциюПока(ИнструкцияПока)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПока Цикл
		Подписка.ПосетитьИнструкциюПока(ИнструкцияПока, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияПока);
	ПосетитьВыражение(ИнструкцияПока.Условие);
	ПосетитьИнструкции(ИнструкцияПока.Инструкции);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииПока Цикл
		Подписка.ПослеПосещенияИнструкцииПока(ИнструкцияПока, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюПока()

Процедура ПосетитьИнструкциюДля(ИнструкцияДля)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюДля Цикл
		Подписка.ПосетитьИнструкциюДля(ИнструкцияДля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияДля);
	ПосетитьВыражениеИдентификатор(ИнструкцияДля.Идентификатор);
	ПосетитьВыражение(ИнструкцияДля.НачинаяС);
	ПосетитьВыражение(ИнструкцияДля.По);
	ПосетитьИнструкции(ИнструкцияДля.Инструкции);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииДля Цикл
		Подписка.ПослеПосещенияИнструкцииДля(ИнструкцияДля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюДля()

Процедура ПосетитьИнструкциюДляКаждого(ИнструкцияДляКаждого)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюДляКаждого Цикл
		Подписка.ПосетитьИнструкциюДляКаждого(ИнструкцияДляКаждого, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияДляКаждого);
	ПосетитьВыражениеИдентификатор(ИнструкцияДляКаждого.Идентификатор);
	ПосетитьВыражение(ИнструкцияДляКаждого.Из);
	ПосетитьИнструкции(ИнструкцияДляКаждого.Инструкции);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииДляКаждого Цикл
		Подписка.ПослеПосещенияИнструкцииДляКаждого(ИнструкцияДляКаждого, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюДляКаждого()

Процедура ПосетитьИнструкциюПопытка(ИнструкцияПопытка)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПопытка Цикл
		Подписка.ПосетитьИнструкциюПопытка(ИнструкцияПопытка, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияПопытка);
	ПосетитьИнструкции(ИнструкцияПопытка.Попытка);
	ПосетитьИнструкциюИсключение(ИнструкцияПопытка.Исключение);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииПопытка Цикл
		Подписка.ПослеПосещенияИнструкцииПопытка(ИнструкцияПопытка, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюПопытка()

Процедура ПосетитьИнструкциюИсключение(ИнструкцияИсключение)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюИсключение Цикл
		Подписка.ПосетитьИнструкциюИсключение(ИнструкцияИсключение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияИсключение);
	ПосетитьИнструкции(ИнструкцияИсключение.Инструкции);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииИсключение Цикл
		Подписка.ПослеПосещенияИнструкцииИсключение(ИнструкцияИсключение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюИсключение()

Процедура ПосетитьИнструкциюПерейти(ИнструкцияПерейти)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПерейти Цикл
		Подписка.ПосетитьИнструкциюПерейти(ИнструкцияПерейти, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииПерейти Цикл
		Подписка.ПослеПосещенияИнструкцииПерейти(ИнструкцияПерейти, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюПерейти()

Процедура ПосетитьИнструкциюМетка(ИнструкцияМетка)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюМетка Цикл
		Подписка.ПосетитьИнструкциюМетка(ИнструкцияМетка, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииМетка Цикл
		Подписка.ПослеПосещенияИнструкцииМетка(ИнструкцияМетка, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюМетка()

#КонецОбласти // ПосещениеИнструкций

#Область ПосещениеПрепроцессора

Процедура ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессора)
	Перем Тип, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессора Цикл
		Подписка.ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессора, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Тип = ВыражениеПрепроцессора.Тип;
	Если Тип = Узлы.ВыражениеПрепроцессораСимвол Тогда
		ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессора);
	ИначеЕсли Тип = Узлы.ВыражениеПрепроцессораБинарное Тогда
		ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессора);
	ИначеЕсли Тип = Узлы.ВыражениеПрепроцессораНе Тогда
		ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессора);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияПрепроцессора Цикл
		Подписка.ПослеПосещенияВыраженияПрепроцессора(ВыражениеПрепроцессора, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессора()

Процедура ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессораСимвол)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораСимвол Цикл
		Подписка.ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессораСимвол, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияПрепроцессораСимвол Цикл
		Подписка.ПослеПосещенияВыраженияПрепроцессораСимвол(ВыражениеПрепроцессораСимвол, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессораСимвол()

Процедура ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессораБинарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораБинарное Цикл
		Подписка.ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессораБинарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеПрепроцессораБинарное);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораБинарное.Левый);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораБинарное.Правый);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияПрепроцессораБинарное Цикл
		Подписка.ПослеПосещенияВыраженияПрепроцессораБинарное(ВыражениеПрепроцессораБинарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессораБинарное()

Процедура ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессораНе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораНе Цикл
		Подписка.ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессораНе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ВыражениеПрепроцессораНе);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораНе.Выражение);
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияВыраженияПрепроцессораНе Цикл
		Подписка.ПослеПосещенияВыраженияПрепроцессораНе(ВыражениеПрепроцессораНе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессораНе()

Процедура ПосетитьИнструкциюПрепроцессора(ИнструкцияПрепроцессора)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПрепроцессора Цикл
		Подписка.ПосетитьИнструкциюПрепроцессора(ИнструкцияПрепроцессора, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ЗакинутьИнформациюНаСтек(ИнструкцияПрепроцессора);
	Если ИнструкцияПрепроцессора.Свойство("Условие") Тогда
		ПосетитьВыражениеПрепроцессора(ИнструкцияПрепроцессора.Условие);
	КонецЕсли;
	СнятьИнформациюСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПослеПосещенияИнструкцииПрепроцессора Цикл
		Подписка.ПослеПосещенияИнструкцииПрепроцессора(ИнструкцияПрепроцессора, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюПрепроцессора()

#КонецОбласти // ПосещениеПрепроцессора

#КонецОбласти // Посетитель

Инициализировать();